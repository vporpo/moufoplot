#!/bin/bash
#
# MoufoPlot 
# Copyright (C) 2012,2013 Vasileios Porpodas <v DOT porpodas AT ed.ac.uk>
#
# MoufoPlot is free software; you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free
# Software Foundation; either version 3, or (at your option) any later
# version.
#
# MoufoPlot is distributed in the hope that it will be useful, but WITHOUT ANY
# WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
# for more details.
#
# You should have received a copy of the GNU General Public License
# along with MoufoPlot; see the file COPYING3.  If not see
# <http://www.gnu.org/licenses/>.

# Changelog
# ---------
# v0.05 05JUL2013 Added geo-mean support
#
# v0.04 06JUN2013 .eps files generated contain the moufoplot data. Regeneration
#                 of graphs works much better this way.
#                 
# v0.03 05JUN2013 Added restore function. Regenerate and modify graphs from 
#                 existing moufoplot .eps files.


MOUFOPLOT_STRING="MoufoPlot"
moufoplot_version="0.05"

MOUFOPLOT_GP_STRING="moufoplot .gp:"
MOUFOPLOT_GP_DATA_STRING="moufoplot data:"
MOUFOPLOT_DATA_STRING="moufodata:"
MOUFOPLOT_DATA_END_STRING="end_moufodata:"

# Printing Functions:
# 1. Print regular message. This gets turned off in silent mode.
print_msg()
{
    if [ ! "${silent}" == "YES" ];then
	printf "${@}" 
    fi
}
# 2. Printe Error message.
print_err()
{
    # if [ ! "${silent}" == "YES" ];then
    printf "${@}"
    # fi
}
# 3. Print the contents of a file. This gets turned off in silent mode.
print_file()
{
    if [ ! "${silent}" == "YES" ];then
	cat "${@}"
    fi
}


debug_stack()
{
    local i=0
    while [ ${i} -lt ${IFS_CNT} ]; do
	print_err "|%s" "${IFS_STACK[${i}]}"
	i=$((${i} + 1))
    done
    print_err "|\n"
}
# set IFS to the given value and save the previous one
set_ifs()
{
    local CURRENT_IFS="${1}"
    IFS="${CURRENT_IFS}"
    IFS_STACK[${IFS_CNT}]="${IFS_PREV}"
    IFS_PREV="${CURRENT_IFS}"
    IFS_CNT=$((IFS_CNT + 1))
    # echo "set_ifs: ->${CURRENT_IFS}<-, stack_cnt:${IFS_CNT}"
    # debug_stack
}

# reset IFS to the last one
reset_ifs()
{
    local IFS_CNT_PREV=$((IFS_CNT - 1))
    if [ ${IFS_CNT_PREV} -ge 0 ];then
	local IFS_CURRENT=${IFS_STACK[${IFS_CNT_PREV}]}
	IFS=${IFS_CURRENT}

    # According to bash man page, the default IFS is:``<space><tab><new-line>''
    # You can only set it back to normal by "unset IFS"
	if [ ${IFS_CNT_PREV} -eq 0 ]; then
	    unset IFS
	fi 

	IFS_CNT=${IFS_CNT_PREV}
	# echo "reset_ifs: ->${IFS_CURRENT}<-, stack_cnt:${IFS_CNT}"
	IFS_PREV="${IFS_CURRENT}"
	# debug_stack

    else
	echo "Too many reset_ifs !!!"
	debug_stack
	exit 1
    fi
}


# Input: FILE
# Output: A string with all the parts separated by space
# Example: get_all_parts_of_file jpeg_otp1_i1_d2
#          Returns: "jpeg opt1 i1 d2"
get_all_parts_of_file()
{
    local f=$1
    local parts=`echo $f |egrep -o "[[:alnum:]-]+"`
    RETVAL=${parts}
}


# Input: FILE PART_NUM
# Output: The value of the PART_NUM part of FILE
# Example: get_part_of_file jpeg_opt1_i1_d2 1 
#          Returns: opt1
get_part_of_file()
{
    local f=${1}
    local part=${2}
    get_all_parts_of_file ${f}
    local parts=${RETVAL}
    RETVAL=${parts[$part]}
}


# Input: FILE
# Output: The number of parts in FILE
# Example: count_parts jpeg_opt1_i1_d2
#         Returns: 4
count_parts()
{
    local f=${1}
    get_all_parts_of_file ${f}
    local p=${RETVAL}
    local parts_cnt=`echo $p|wc -w`
    RETVAL=${parts_cnt}
}


# Input: DIR PART_NUM
# Output: all the unique values in PART_NUM
# Example: get_all_values_in_part data/ 0 (where data/ contains files like jpeg_* and mpeg_*)
#          Returns "jpeg mpeg"
get_all_values_in_part()
{
    local DIR=$1
    local part=$2
    local files=`ls -1 $DIR`
    local all_values=()
    local f
    for f in $files; do
	get_part_of_file ${f} ${part}
	part_value=${RETVAL}
	local found=0
	# for val in ${all_values}; do
	#     if [ "$val" == "${part_value}" ];then
	# 	found=1
	#     fi
	# done
	if [ $found -eq 0 ]; then
	    all_values="${all_values} ${part_value}"
	fi
    done
    RETVAL=${all_values}
}


# Input: NEDDLE HAYSTACK
# Output: 1 if found, 0 if not found
# Example: found_in_array 1 "1 2 3"
#          Returns 1
found_in_array()
{
    local needle=$1
    local haystack=$2
    local found=0
    for hay in ${haystack}; do
	if [ "$needle" == "$hay" ]; then
	    found=1
	fi
    done
    echo $found
}

# Input: FIRST_NUM END_NUM NAME_PREFIX "SKIP_ARRAY"
# Output: the figure names
# Description: Generate names by concatenating the parts that correspond
#              to FIRST_NUM up to END_NUM excluding "SKIP_ARRAY".
gen_names()
{
    local i=$1
    local end_i=$2
    local name=$3
    local skip_i=$4
    
    while [ 0 ]; do
	local should_skip=`found_in_array $i "${skip_i}"`
	if [ $should_skip -eq 1 ];then
	    i=$((i + 1))
	else
	    break
	fi
    done
    local val
    for val in ${val_array[$i]}; do
	gen_names $((i+1)) ${end_i} "${name}_${val}" "${skip_i}"
    done
    if [ $i -eq ${end_i} ];then
	echo $name
    fi
}

# Convert Space Separated Values -> Comma Separated Values
convert_ssv2csv()
{
    local ssv=${1}
    local value
    local csv
    for value in ${ssv};do
	csv="${csv},${value}"
    done
    RETVAL=`echo ${csv}|sed 's/.\(.*\)/\1/'`
}

get_all_dir()
{
    local DIR=$1
    local all=`ls -1 ${DIR}`
    convert_ssv2csv "${all}"
}

get_all_file()
{
    local DIR=$1
    local all=`cat ${DIR} | egrep -o ".+:" | sed 's/://'`
    convert_ssv2csv "${all}"
}

# Usage get_all DIR
# Return all variables in DIR
get_all()
{
    local DIR=$1
    if [ -d ${DIR} ];then
	get_all_dir ${DIR}
    elif [ -f ${DIR} ];then
	get_all_file ${DIR}
    else
	print_err "ERROR: ${DIR} not a file or directory.\n"
	exit 1
   fi
}

regen_suggest()
{
    if [ "${regen}" ]; then
	echo ""
	echo "------------ Run MoufoPlot manually ----------------"
	echo "-regen detected."
	echo "Please use these arguments (skipping --regen) to manually re-run the command, fixing any issues yourself."
	echo ""
	echo "${args}"
    fi 
}


# Search in DIR for files that match FILTERS. Upon error, nclude ERROR_MSG
# in the output message.
# Upon success, return the value of the single match in RETVAL
# Input: DIR FILTERS ERROR_MSG(optional)
# Output: The number that matches
# Example: get_match i2 jpeg d1 opt2
#          Returns the number contained in jpeg_opt2_i2_d1
get_match_dir ()
{
    local DIR=${1}
    local filters=${2}
    local error_msg=${3}
    local grep_cmd=""
    local out=""

    # echo "Matching... ${filters}"

    set_ifs ", "
    for match in $filters; do
	grep_cmd="${grep_cmd}|egrep \"_${match}_|^${match}_|_${match}\\$|^${match}\\$\""
    done
    reset_ifs

    grep_cmd="ls -1 ${DIR}${grep_cmd}"
    # echo "GREP_CMD: $grep_cmd"

    local filename=`eval ${grep_cmd}`
    local count_files=`echo $filename|wc -w`
    if [ ${count_files} -ne 1 ]; then
	if [ "${ignore_filter}" == "YES" ]&&[ ${count_files} -eq 0 ];then
	    echo -e "\nWARNING: ${error_msg} Filter -f: ${filters} matches ${count_files} files in ${DIR} !!!"
	    RETVAL=""
	    return
	else
	    echo -e "\nERROR: ${error_msg} Filter: ${filters} matches ${count_files} files in ${DIR} !!!"
    	    echo -e "The following files all match the filter:\n$filename"
	    echo -e "Please add more constraints into the filter ${filters}."
	    regen_suggest
    	    exit 1
	fi
    fi
    # echo $filename
    out="${filename} ${out}"
    RETVAL=${out}
    get_file_value "${DIR}/${RETVAL}"
}


# Search in FILE for lines that match FILTERS. Upon error, nclude ERROR_MSG
# in the output message.
# Upon success, return the value of the single match in RETVAL
# Input: FILE FILTERS ERROR_MSG(optional)
# Output: The number that matches
# Example: get_match i2 jpeg d1 opt2
#          Returns the number contained in jpeg_opt2_i2_d1
get_match_file ()
{
    local FILE=${1}
    local filters=${2}
    local error_msg=${3}
    local grep_cmd=""
    local out=""

    # echo "Matching... ${filters}"

    set_ifs ", "
    for match in $filters; do
	grep_cmd="${grep_cmd}|egrep \"_${match}_|^${match}_|_${match}:|^${match}:\""  #1st change \\$->:
    done
    reset_ifs

    grep_cmd="cat ${FILE}${grep_cmd}"  #2nd change "cat"
    # echo "GREP_CMD: $grep_cmd"

    local filename=`eval ${grep_cmd}`
    # echo "filename: ${filename}"
    local count_files=`echo $filename|wc -l`  #3rd change
    if [ ${count_files} -ne 1 ]; then
	if [ "${ignore_filter}" == "YES" ]&&[ ${count_files} -eq 0 ];then
	    echo -e "\nWARNING: ${error_msg} Filter -f: ${filters} matches ${count_files} lines in ${FILE} !!!" #4th change files->lines
	    RETVAL=""
	    return
	else
	    echo -e "\nERROR: ${error_msg} Filter: ${filters} matches ${count_files} lines in ${FILE} !!!" #5th change files->lines
    	    echo -e "The following lines all match the filter:\n$filename"
	    echo -e "Please add more more constraints to the filter ${filters}."
	    regen_suggest
    	    exit 1
	fi
    fi
    # echo $filename
    # out="${filename} ${out}"
    local number=`echo ${filename} | egrep -o ":.+" | sed 's/://' | sed 's/ //g'`
    # echo "NUMBER:${number}"
    fix_exponential ${number}
}

# Switch between DIR/FILE mode
get_match()
{
    local dir=${1}
    local opts=${2}
    local error_msg=${3}

   if [ -d "${DIR}" ];then
       get_match_dir "${dir}" "${opts}" "${error_msg}"
   elif [ -f "${DIR}" ];then
       get_match_file "${dir}" "${opts}" "${error_msg}"
   else
       print_err "ERROR: ${DIR} not a file or directory.\n"
       exit 1
   fi

   if [ "${RETVAL}" == "" ];then
       if [ "${ignore_filter}" == "YES" ];then
	   RETVAL=0
       else
	   print_err "\nERROR: Can't find value that matches: ${opts} in ${dir}\n"
	   exit 1
       fi
   fi
}

# Input: X_ARRAY MAX
# Output: An array of the part numbers that are not part of the X Axis.
# Example: get_not_x "0 1" 4
#          Returns "2 3"
get_not_x()
{
    local x_values=$1
    local parts_cnt=$2
    local i=0
    while [ $i -lt ${parts_cnt} ]; do
	local found=`found_in_array $i "${x_values}"`
	if [ $found -eq 0 ]; then
	    local not_x_values="${not_x_values} $i"
	fi
	i=$((i+1))
    done
    echo ${not_x_values}
}


# Change input number from exponential notation to regular
fix_exponential()
{
    local data=$1
    is_number "${data}"
    local isnum=${RETVAL}
    if [ "${isnum}" == "no" ];then
	is_exponential_notation "${data}"
	local isexp=${RETVAL}
	if [ "${isexp}" == "no" ];then
	    exit 1
	else
	    # number is in exponential notation. we have to convert it to float
	    local first=`echo ${data} | egrep -o "[0-9]+(\.[0-9]+|)" | head -n 1`
	    local last=`echo ${data} | egrep -o "([Ee]\+[0-9]+|)" |egrep -o "[0-9]+"`
	    # echo "data: ${data}, first: ${first}, last: ${last}"
	    local float_val=`echo "${first} * 10 ^ ${last}" |bc -l`
	    data=${float_val}
	fi
    fi
    # echo ${data}
    RETVAL=${data}
}


# Input: FILE
# Output: The number contained in FILE
# Example: get_file_value jpeg_opt1_i2_d1
#          Returns 34896523
get_file_value()
{
    eval local file="$1"
    # local data=`cat ${file}`
    local data=$(< ${file})
    if [ ! "${silent}" == "YES" ];then
	echo "Reading value from ${file}... ${data}"
    fi
    if [ "$data" == "" ]; then
	if [ "${ignore_filter}" == "YES" ];then
	    echo "WARNING: ignoring empty ${file}."
	    RETVAL=0
	    return
	else
	    echo "ERROR: file ${file} is empty!!!"
	    exit 1
	fi
    fi
    
    fix_exponential "${data}"
    if [ $? -ne 0 ];then
	echo "ERROR: file: ${file}: ${data} is not a number OR an exponential."
	exit 1
    fi
    RETVAL=${RETVAL}
}

# Input: DATA_FILE_ARRAY OUT_DIR
# Output: NORMALIZED_DATA_FILE_ARRAY
normalize()
{
    local RES_DIR=$1
    local OUT_DIR=$2

    if [ ! -d ${OUT_DIR} ]; then
	mkdir ${OUT_DIR}
    fi

    # value=`cat ${RES_DIR}/*_NOED_i1_d1`
    local value=$(< ${RES_DIR}/*_NOED_i1_d1) # Performance optimization

    local results=`ls -1 ${RES_DIR}`

    for result in ${results}; do
	result_path="${RES_DIR}/${result}"
	# result_num=`cat ${result_path}`
	result_num=$(< ${result_path}) # Performance optimization
	normalized_result_num=`echo "${result_num}/${value}" | bc -l`
	normalized_result_path="${OUT_DIR}/${result}"
	echo ${normalized_result_num} > ${normalized_result_path}
    done
    echo "Done!"
}

is_exponential_notation()
{
    local value=${1}
    local grepped_val=`echo ${1} | egrep -o "[0-9]+(\.[0-9]+|)([Ee]\+[0-9]+|)" | head -n 1`
    if [ "${value}" == "${grepped_val}" ]; then
	RETVAL="yes"
    else
	RETVAL="no"
    fi
}

get_number()
{
    local value=${1}
    local grepped_val=`echo ${1} | egrep -o "(-|)([[:digit:]]+\.*[[:digit:]]*)" | head -n 1`
    RETVAL=${grepped_val}
}


is_number()
{
    local value=${1}
    get_number ${value}
    local number=${RETVAL}
    # grepped_val=`echo ${1} | egrep -o "(-|)([[:digit:]]+\.*[[:digit:]]*)" | head -n 1`
    if [ "${value}" == "${number}" ]; then
	RETVAL="yes"
    else
	RETVAL="no"
    fi
}


is_integer()
{
    local value=${1}
    local grepped_val=`echo ${1} | egrep -o "(-|)([[:digit:]])+"`
    if [ "${value}" == "${grepped_val}" ]; then
	RETVAL="yes"
    else
	RETVAL="no"
    fi
}

gp_xy_format()
{
    if [ "${x_format}" != "" ];then
	echo "set format x \"${x_format}\"" >> ${gpfname}
    fi
    if [ "${y_format}" != "" ];then
	echo "set format y \"${y_format}\"" >> ${gpfname}
    fi
}

gp_labels()
{
    echo "set xlabel \" ${x_title}\" offset 0,${x_label_offset}"  >> ${gpfname}
    if [ "${y_title}" != "" ]; then
	echo "set ylabel \"${y_title}\" offset ${y_label_offset},0"  >> ${gpfname}
    fi
}

gp_size()
{
    local size="${size_param_x},${size_param_y}"
    echo "set size ${size}" >> ${gpfname}
}

gp_terminal()
{
    echo "set term ${gp_terminal_cmd}" > ${gpfname} 
}

gp_output()
{
    echo "set output \"${epsfile}\"" >>${gpfname}
}

gp_xytics_rotate()
{
    echo "set xtics rotate by ${x_tics_rotate} offset character 0,0 nomirror" >> ${gpfname}
    echo "set ytics rotate by ${y_tics_rotate} offset character 0,0 nomirror" >> ${gpfname}
}

gp_title()
{
    if [ "${title}" != "" ];then
	echo "set title \"${title}\" " >> ${gpfname}
    fi
}

gp_set_grid()
{
    echo "set grid y" >>${gpfname}
    # echo "set grid x" >>${gpfname}
}

gp_key()
{
    echo "${key_command}" >> ${gpfname}
}

# pretty_tics
gp_ytics()
{
    if [ "${y_range_step}" == "" ];then
	# y_range_step=`echo "(${max_value} - ${min_value}) / ${y_tics}"|bc -l`
	y_range_step=`echo "(${max_value} - 0) / ${y_tics}"|bc -l`
	local is_y_dist_gt3=`greater_than ${y_range_step} 3`
	if [ "${is_y_dist_gt3}" == "1" ];then
	    y_range_step=${y_range_step/.*}
	fi
    fi
    if [ "${y_tics}" == "0" ];then
	echo "unset ytics" >> ${gpfname}
    else
	echo "set ytics ${y_range_step}" >> ${gpfname}
    fi
}

gp_yrange()
{
    if [ "${y_range}" != "" ]; then
	echo "set yrange[${y_range_min}:${y_range_max}]">> ${gpfname}
    else
	if [ "${plot_type}" == "stacked" ];then
	    local extra_ratio=0
	else
	    local extra_ratio=0.40
	fi
	local extra_tics=`echo "${y_tics} * ${extra_ratio}" | bc -l`
	extra_tics=${extra_tics/.*}
	local y_max=`echo "(${y_tics} + ${extra_tics})  * ${y_range_step}"|bc -l`
	echo "set yrange[0:${y_max}]" >> ${gpfname}
    fi
}

gp_fonts()
{
    # local font_type="Times"  # Does not work with png,jpeg
    local title_font_size="18"
    local legend_font_size="14"
    local legend_font_spacing="0.9"
    local tags_font_size="16"
    local xlabel_font_size="16"
    local ylabel_font_size="16"


    echo "set tics font \"${font_type},${tags_font_size}\""  >> ${gpfname}
    echo "set key font \"${font_type},${legend_font_size}\" spacing ${legend_font_spacing}">> ${gpfname}
    echo "set title font \"${font_type},${title_font_size}\" " >> ${gpfname}
    echo "set ylabel font \"${font_type},${ylabel_font_size}\" " >> ${gpfname}
    echo "set xlabel font \"${font_type},${xlabel_font_size}\" " >>${gpfname}
}

gp_bar_options()
{
    local rowstacked=${1}
    gp_terminal
    gp_output
    gp_size
    gp_xytics_rotate
    gp_set_grid
    gp_xy_format
    gp_fonts
    gp_key
    gp_title
    gp_ytics
    gp_yrange 

    # Bargraph specific
    if [ "${bar_width}" != "" ];then
	echo "set boxwidth ${bar_width} relative" >> ${gpfname}
    fi
    echo "set style data histograms" >> ${gpfname}
    # offset is relative to xlabel


    if [ "${rowstacked}" == "" ];then
	if [ "${cluster_gap}" != "" ]; then
    	    echo "set style histogram cluster gap ${cluster_gap} title offset 0,${z_tags_offset}" >> ${gpfname}
	else
    	    echo "set style histogram cluster gap 1 title offset 0,${z_tags_offset}" >> ${gpfname}
	fi
    else
    	echo "set style histogram ${rowstacked} title offset 0,${z_tags_offset}" >> ${gpfname}
    fi

    echo "set style fill solid 1.0 border lt \"black\"" >> ${gpfname}
    echo "set grid ytics ls 10 lt rgb \"black\"" >> ${gpfname}

    gp_labels

    # PLOT
    local plot_cmd="plot "
    local x_set_array=(${x_set})
    local x
    local cmn=2
    set_ifs "${IFS_CHAR}"
    local xi=0
    local z

    if [ "${z_vals}" == "" ];then
	while [ ${xi} -lt ${max_x} ]; do
	# skip masked
	    if [ "${x_mask}" != "" ]&&[ "${x_mask_array[${xi}]}" == "0" ];then
		xi=$((${xi} + 1))
		continue
	    fi

	    local color=${color_array[$cmn]}

	    plot_cmd="${plot_cmd} \"${data_file}\" using ${cmn}:xtic(1) with histograms title columnheader(${cmn}) lt ${line_type_array[${xi}]} lw ${line_width} lc rgb \"${color}\","
	    cmn=$((cmn+1))
	    xi=$((${xi} + 1))
	done
    else
	local zi=0
	while [ ${zi} -lt ${max_z} ];do
	    local cmn=2

	    if [ "${noz_tags}" == "YES" ];then
		local ztag=""
	    else
		local ztag=${ztags_array[${zi}]}
	    fi

	    plot_cmd="${plot_cmd} newhistogram \"${ztag}\", "
	    # for x in ${x_vals}; do
	    local xi=0
	    while [ ${xi} -lt ${max_x} ]; do
		# skip masked
		if [ "${x_mask}" != "" ]&&[ "${x_mask_array[${xi}]}" == "0" ];then
		    xi=$((${xi} + 1))
		    continue
		fi

		local color=${color_array[$cmn]}
		if [ ${zi} -eq 0 ];then
		    local title_stuff="title columnheader(${cmn})"
		else
		    local title_stuff="notitle"
		fi
		plot_cmd="${plot_cmd} \"${data_file}\" index ${zi} using ${cmn}:xtic(1) with histograms ${title_stuff} lt ${line_type_array[${xi}]} lw ${line_width} lc rgb \"${color}\","
		cmn=$((cmn+1))
		xi=$((${xi} + 1))
	    done
	    zi=$((${zi} + 1))
	done
    fi
    reset_ifs

    if [ "${plot_cmd}" == "plot " ];then
	echo "SANITY ERROR: plot_cmd is incorrect"
	exit 1
    fi

    echo "${plot_cmd%?}" >> ${gpfname}
}

gp_line_options()
{
    gp_terminal
    gp_output
    gp_size
    gp_xytics_rotate
    gp_set_grid
    gp_xy_format
    gp_fonts
    gp_key
    gp_title
    gp_ytics
    gp_yrange
    echo "set xrange[0:]" >> ${gpfname}
    gp_labels

    # PLOT
    local plot_cmd="plot "
    local x_set_array=(${x_set})
    local x
    local cmn=2
    local xi=0
    set_ifs "${IFS_CHAR}"
    # for x in ${x_vals}; do
    while [ ${xi} -lt ${max_x} ]; do
	# skip masked
	if [ "${x_mask}" != "" ]&&[ "${x_mask_array[${xi}]}" == "0" ];then
	    xi=$((${xi} + 1))
	    continue
	fi

	local color=${color_array[$cmn]}

	plot_cmd="${plot_cmd} \"${data_file}\" using ${cmn}:xtic(1) with linespoints title columnheader(${cmn}) lw ${line_width} ps ${point_size} pt ${point_type_array[${xi}]} lt ${line_type_array[${xi}]} lc rgb \"${color}\","
	cmn=$((cmn+1))
	xi=$((${xi} + 1))
    done
    reset_ifs
    echo "${plot_cmd%?}" >> ${gpfname}
}

gp_hmap_options()
{
    gp_terminal
    gp_output
    gp_size
    gp_xytics_rotate
    gp_xy_format
    gp_fonts

    # Heatmap excluseive options
    echo "set palette rgbformula 7,7,7" >> ${gpfname}
    echo "set palette rgbformula 30,31,32" >> ${gpfname}
    echo "set cblabel \"${z_label}\""  >> ${gpfname}
    # echo "unset cbtics" >> ${gpfname} # This removes tics from heat bar
    echo "set cbtics" >> ${gpfname} 
    echo "unset key" >> ${gpfname} # Otherwise the filename is displayed

    gp_title
    gp_labels

    create_tics "x"
    local xtics_cmd="${RETVAL}"
    echo "${xtics_cmd}" >> ${gpfname}

    create_tics "y"
    local ytics_cmd="${RETVAL}"
    echo "${ytics_cmd}" >> ${gpfname}

 
	# PLOT
    local plot_cmd="plot "
    plot_cmd="${plot_cmd} \"${data_file}\" matrix with image"
    echo "${plot_cmd}" >> ${gpfname}
}

create_tics()
{
    local xORy="${1}"
    # TICS: set xtics ("aaa" 0, "bbb" 1, ...)

    set_ifs ","
    if [ "${xORy}" == "x" ];then
	local x
	local xtics_cmd="set xtics ("
	local skipped=0
	local xi=0
	# for x in ${x_vals}; do
	while [ ${xi} -lt ${max_x} ]; do
	    # skip X masked data
	    if [ "${x_mask}" != "" ]&&[ "${x_mask_array[${xi}]}" == "0" ];then
		xi=$((${xi} + 1))
		skipped=$((${skipped} + 1))
		continue
	    fi

	    if [ "${nox_tags}" == "YES" ]; then
		local tag="\"\""
	    else
		local tag="${xtags_array[${xi}]}"
	    fi
	    xtics_cmd="${xtics_cmd}\"${tag}\" $((${xi}-${skipped})),"
	    xi=$((${xi} + 1))
	done
	RETVAL="${xtics_cmd%?})"
    elif [ "${xORy}" == "y" ];then
	local y
	if [ "${y_vals}" != "" ];then
	    local ytics_cmd="set ytics ("
	else
	    local ytics_cmd=""
	    RETVAL=""
	    return
	fi
	local yi=0
	local skipped=0
	# for y in ${y_vals}; do
	while [ ${yi} -lt ${max_y} ]; do
            # skip Y masked data
	    if [ "${y_mask}" != "" ]&&[ "${y_mask_array[${yi}]}" == "0" ];then
		yi=$((${yi} + 1))
		skipped=$((${skipped} + 1))
		continue
	    fi

	    if [ "${noy_tags}" == "YES" ]; then
		local tag="\"\""
	    else
		local tag="${ytags_array[${yi}]}"
	    fi
	    ytics_cmd="${ytics_cmd}\"${tag}\" $((${yi} - ${skipped})),"
	    yi=$((${yi} + 1))
	done
	ytics_cmd="${ytics_cmd%?})"
	RETVAL=${ytics_cmd}
     fi
    reset_ifs 
}



init_ifs()
{
    IFS_PREV=" "
}

find_min_max()
{
    local file_val=${1}
    if [ "${max_value}" == "" ];then
	max_value=${file_val}
    else
	local isgt=`greater_than ${file_val} ${max_value}`
	if [ "${isgt}" == "1" ];then
	    max_value=${file_val}
	fi
    fi
    if [ "${min_value}" == "" ];then
	min_value=${file_val}
    else
	local islt=`less_than ${file_val} ${max_value}`
	if [ "${islt}" == "1" ];then
	    min_value=${file_val}
	fi
    fi
}


# Input: filter (-f)
# Output: creates FILENAME and puts in it all the data.
# Description: Create the data file for a figure. 
create_data_file()
{
    local rowstacked=${1}
    local filter=${2}

    local x
    local y
    local z
    local fig_options=`get_all_parts_of_file "${fig_file}"`

    print_msg "Creating data file ${data_file} ...\n"
    set_ifs "${IFS_CHAR}" # Let ',' be the separator character

    local data="NULL"

    local xi=0
    for x in ${x_array}; do
	if [ "${nox_tags}" == "YES" ]||[ "${no_x}" == "1" ];then
	    local xtag="\"\""
	else
	    local xtag=${xtags_array[${xi}]}
	fi

        # skip masked data
	if [ "${x_mask}" != "" ]&&[ "${x_mask_array[${xi}]}" == "0" ];then
	    xi=$((${xi} + 1))
	    continue
	fi

	data="${data} ${xtag}"
	xi=$((${xi} + 1))
    done
    data="${data}\n"




    local zi=0
    for z in ${z_array};do
	if [ "${no_z}" == "1" ];then
	    z=""
	fi

	data="${data}# ${z}\n"
	local yi=0    
	local normalize_value=1.0
	for y in ${y_array}; do
	    if [ "${no_y}" == "1" ];then
		y=""
	    fi

	    if [ "${noy_tags}" == "YES" ];then
		ytag="\"\""
	    else
		ytag=${ytags_array[${yi}]}
		if [ "${ytag}" == "" ];then
		    ytag="\"\""
		fi
	    fi
	    
            # Normalization on the Y axis
	    if [ "${y_norm_array[${yi}]}" != "" ];then
		normalize_value=`echo ${y_norm_array[${yi}]}*1.0|bc -l`
	    fi

	    # Normalization on the Z axis
	    if [ "${z_norm_array[${zi}]}" != "" ];then
		normalize_value=`echo ${z_norm_array[${zi}]}*1.0|bc -l`
	    fi

	    # skip Y tag (masked Y)
	    if [ "${y_mask_array[${yi}]}" != "0" ];then
		data="${data}${ytag}"
	    fi

	    local sum_x_all=0
	    local sumx
	    if [ ${x_geomean_flag} ]; then
		sumx=1
	    else
		sumx=0
	    fi
	    local xi=0

	    for x in ${x_array}; do
		if [ "${no_x}" == "1" ];then
		    x=""
		fi

			

		if [ "${y_avg}" ]&&[ ${yi} -eq $((${max_y} - 1)) ];then
		    if [ "${y_geomean_flag}" ]; then
			file_val=`echo "e(l(${ysum[${xi}]}) / ${avg_max_y})" | bc -l` # root of
		    else 
			file_val=`echo "(${ysum[${xi}]}) / ${avg_max_y}" | bc -l`
		    fi 
		elif [ "${x_avg}" ]&&[ ${xi} -eq $((${max_x} - 1)) ]; then
		    if [ "${x_geomean_flag}" ]; then
			file_val=`echo "e(l(${sumx}) / ${avg_max_x})" | bc -l` # root of
		    else
			file_val=`echo "(${sumx})/${avg_max_x}" | bc -l`
		    fi
		else 


		# if [ ${xi} -lt ${max_x} ]&&[ ${yi} -lt ${max_y} ]&&[ ${zi} -lt ${max_z} ];then # x/y avg
		    local opts="${x} ${y} ${z} ${filter}"
		    get_match "${DIR}" "$opts" "create_data_file"
		    file_val=${RETVAL}

	            # Normalization on the X axis
		    if [ "${x_norm_array[${xi}]}" != "" ];then
			normalize_value=`echo "${x_norm_array[${xi}]} * 1.0"|bc -l`
		    fi
		    if [ "${ignore_filter}" == "YES" ]&&[ "${file_val}" == "0" ]||[ "${ignore_filter}" == "YES" ]&&[ "${normalize_value}" == "0" ];then
			file_val=0
		    else
			file_val=`echo "${file_val} / ${normalize_value}"|bc -l`
		    fi

		    if [ "${percent}" != "" ];then
			file_val=`echo "${file_val} * 100" |bc -l`
		    fi
		fi
		sum_x_all=`echo "${sum_x_all} + ${file_val}" | bc -l`

		# Find minimum, maximum value (to use it in pretty ytics)
		if [ "${rowstacked}" != "" ]; then
			find_min_max ${sum_x_all}
		else
			find_min_max ${file_val}
		fi

		# skip X,Y masked data
		if [ "${x_mask_array[${xi}]}" != "0" ]&&[ "${y_mask_array[${yi}]}" != "0" ];then
		    data="${data} ${file_val}"
		fi

		in_array ${xi} "${x_avg_array[@]}"
		if [ $? -eq 0 ];then
		    if [ ${x_geomean_flag} ]; then
			if [ "${ignore_filter}" == "YES" ]; then
			    if [ "${file_val}" != "0" ];then
				sumx="${sumx} * ${file_val}"
			    else
				sumx="${sumx} * 1"
			    fi
			else
			    sumx="${sumx} * ${file_val}"
			fi
		    else
			sumx="${sumx} + ${file_val}"
		    fi
		fi

		in_array ${yi} "${y_avg_array[@]}"
		if [ $? -eq 0 ];then
		    if [ ${y_geomean_flag} ]; then
			if [ "${ignore_filter}" == "YES" ]; then
			    if [ "${file_val}" != "0" ];then
				ysum[${xi}]="${ysum[${xi}]} * ${file_val}"
			    else
				ysum[${xi}]="${ysum[${xi}]} * 1"
			    fi
			else
			    ysum[${xi}]="${ysum[${xi}]} * ${file_val}"
			fi
		    else
			ysum[${xi}]="${ysum[${xi}]} + ${file_val}"
		    fi 
		fi

		xi=$((${xi} + 1))
	    done

	    # skip Y newline (masked Y)
	    if [ "${y_mask_array[${yi}]}" != "0" ];then
		data="${data}\n"
	    fi
	    yi=$((${yi} + 1))
	done
	if [ "${z_mask_array[${zi}]}" != "0" ];then
	    data="${data}\n\n"
	fi
	zi=$((${zi} + 1 ))
    done
    reset_ifs
    print_msg " Done.\n"
    # Dump data
    echo -e ${data} > ${data_file}
    print_file "${data_file}"
}


in_array()
{
    local hay needle=${1}
    shift
    for hay; do
        [[ ${hay} == ${needle} ]] && return 0
    done
    return 1
}

# Input: filter (-f)
# Output: creates FILENAME and puts in it all the data.
# Description: Create the data file for a heatmap. 
create_data_file_hmap()
{
    local filter=$1
    local data_file=${data_file}

    local x
    local y
    local fig_options=`get_all_parts_of_file "${fig_file}"`

    set_ifs "${IFS_CHAR}" # Let ',' be the separator character

    local data=""
    local xi=0, yi=0, zi=0
    for y in ${y_array}; do
	if [ "${no_y}" == "1" ];then
	    y=""
	fi
	local sumx
	if [ "${x_geomean_flag}" ]; then
	    sumx=1
	else
	    sumx=0
	fi 
	local xi=0

	for x in ${x_array}; do
	    if [ "${no_x}" == "1" ];then
		x=""
	    fi

	    if [ "${y_avg}" ]&&[ ${yi} -eq $((${max_y} - 1)) ];then
		if [ "${y_geomean_flag}" ]; then
		    file_val=`echo "e(l(${sumy[${xi}]}) / ${avg_max_y})" | bc -l` # root of
		else 
		    file_val=`echo "(${sumy[${xi}]}) / ${avg_max_y}" | bc -l`
		fi 
	    elif [ "${x_avg}" ]&&[ ${xi} -eq $((${max_x} - 1)) ];then
		if [ "${x_geomean_flag}" ]; then
		    file_val=`echo "e(l(${sumx}) / ${avg_max_x})" | bc -l` # root of
		else
		    file_val=`echo "(${sumx})/${avg_max_x}" | bc -l`
		fi
	    else
	    # if [ ${xi} -lt ${max_x} ]&&[ ${yi} -lt ${max_y} ]&&[ ${zi} -lt ${max_z} ];then # x/y avg
		local opts="${x} ${y} ${filter}"
		get_match "$DIR" "$opts" "create_data_file_hmap"
		local file_val=${RETVAL}
		if [ "${percent}" != "" ];then
		    file_val=`echo "${file_val} * 100" |bc -l`
		fi
	    fi
	    if [ "${x_mask_array[${xi}]}" != "0" ]&&[ "${y_mask_array[${yi}]}" != "0" ];then
		data="${data}${file_val} "
	    fi


	    in_array ${xi} "${x_avg_array[@]}"
	    if [ $? -eq 0 ];then
		if [ "${x_geomean_flag}" ]; then
		    if [ "${ignore_filter}" == "YES" ]; then
			if [ "${file_val}" != "0" ];then
			    sumx="${sumx} * ${file_val}"
			else
			    sumx="${sumx} * 1"
			fi
		    else
			sumx="${sumx} * ${file_val}"
		    fi 
		else
		    sumx="${sumx} + ${file_val}"
		fi 
	    fi

	    in_array ${yi} "${y_avg_array[@]}"
	    if [ $? -eq 0 ];then
		if [ "${y_geomean_flag}" ]; then
		    if [ "${sumy[${xi}]}" == "" ];then
			sumy[${xi}]=${file_val}
		    else
			if [ "${ignore_filter}" == "YES" ]; then
			    if [ "${file_val}" != "0" ];then
				ysum[${xi}]="${ysum[${xi}]} * ${file_val}"
			    else
				ysum[${xi}]="${ysum[${xi}]} * 1"
			    fi
			else
			    sumy[${xi}]="${sumy[${xi}]} * ${file_val}"
			fi 
		    fi 
		else 
		    sumy[${xi}]="0${sumy[${xi}]} + ${file_val}"
		fi
	    fi
	    xi=$((${xi} + 1))
	done

	if [ "${y_mask_array[${yi}]}" != "0" ];then
	    data="${data}\n"
	fi
	yi=$((${yi} + 1))
    done
    reset_ifs
    echo "${data_file}"
    echo "- - - - - - - - - - - -"
    echo -e $data |tee ${data_file}
}


check_if_arguments_exist()
{
    set_ifs "${IFS_CHAR}" # Let ',' be the separator character
    local vals1=$1
    local vals2=$2
    local vals3=$3
    local vals4=$4
    local dir=$4
    local val1
    local val2
    local val3
    local val4
    for val1 in ${vals1}; do
	for val2 in ${vals2}; do
	    for val3 in ${vals3}; do
		for val4 in ${vals4}; do
		    get_match "${DIR}" "${val1} ${val2} ${val3} ${val4}" "check_if_arguments_exist" "NO"
		    local match=${RETVAL}
		    if [ "${match}" == "" ]; then
			echo "ERROR: Filters: ${val1} ${val2} ${val3} are too restrictive! Can't find match in ${DIR}."
			exit 1
		    fi
		done
	    done
	done
    done
    reset_ifs
}


greater_than()
{
    local result=`echo "${1} > ${2}"|bc -l`
    if [ ${PIPESTATUS} -eq 0 ];then
	echo ${result}
    else
	echo "ERROR"
    fi
}
less_than()
{
    local result=`echo "${1} < ${2}"|bc -l`
    if [ ${PIPESTATUS} -eq 0 ];then
	echo ${result}
    else
	echo "ERROR"
    fi
}


sanity_checks()
{
    if [ ! -d "${DIR}" ]&&[ ! -f "${DIR}" ]; then
	echo "ERROR: File/Directory \"${dir}\" does not exist ! (wrong --dir ???)"
	exit 1
    fi

    if [ "${data_file}" == "" ] || [ "${data_dir}" == "/" ];then
	echo "ERROR: data file == '/'  !!!"
	exit 1
    fi

    local data_file_dir=${data_file%/*}
    if [ ! -d "${data_file_dir}" ]; then
	mkdir -p $data_file_dir
	if [ $? -ne 0 ]; then
	    echo "ERROR: Can't create ${data_file_dir} for ${data_file}."
	    exit 1
	fi
    fi

    check_if_arguments_exist "${x_vals}" "${y_vals}" "${z_vals}" "${others}" "${DIR}"

    if [ $? -ne 0 ]; then exit 1; fi    

    if [ "${x_norm}" != "" ]&&[ "${y_norm}" != "" ]; then
	echo "ERROR: Can't enable BOTH --xnorm AND --ynorm"
	exit 1
    fi
    if [ "${x_norm}" != "" ]&&[ "${z_norm}" != "" ]; then
	echo "ERROR: Can't enable BOTH --xnorm AND --znorm"
	exit 1
    fi
    if [ "${y_norm}" != "" ]&&[ "${z_norm}" != "" ]; then
	echo "ERROR: Can't enable BOTH --ynorm AND --znorm"
	exit 1
    fi


    if [ "${x_tics_rotate}" != "" ];then
	is_integer ${x_tics_rotate}
	local angle_is_integer=${RETVAL}
	if [ "${angle_is_integer}" == "no" ];then
	    echo "ERROR: X rotate must be an integer, not: ${x_tics_rotate}."
	    exit 1
	fi
    fi
    if [ "${y_tics_rotate}" != "" ];then
	is_integer ${y_tics_rotate}
	local angle_is_integer=${RETVAL}
	if [ "${angle_is_integer}" == "no" ];then
	    echo "ERROR: Y rotate must be an integer, not: ${y_tics_rotate}."
	    exit 1
	fi
    fi


    # size is number
    if [ "${size_param}" != "" ];then
	is_number ${size_param_x}
	local is=${RETVAL}
	if [ "${is}" == "no" ];then
	    echo "ERROR: size of x: ${size_param_x} in size parameter ${size_param} is not a number."
	    exit 1
	fi
	is_number ${size_param_y}
	local is=${RETVAL}
	if [ "${is}" == "no" ];then
	    echo "ERROR: size of y: ${size_param_y} in size parameter ${size_param} is not a number."
	    exit 1
	fi
	isgt0=`greater_than ${size_param_x} 0`
	if [ "${isgt0}" == "0" ]; then
	    echo "ERROR: Wrong X size: ${size_param_x} of param:${size_param}. Must be > 0."
	    exit 1
	fi
	isgt0=`greater_than ${size_param_y} 0`
	if [ "${isgt0}" == "0" ]; then
	    echo "ERROR: Wrong Y size ${size_param_y} of param:${size_param}. Must be > 0."
	    exit 1
	fi
    fi


    # X,Y tics
    if [ "${x_tics}" != "" ];then
	is_integer ${x_tics}
	local is=${RETVAL}
	if [ "${is}" != "yes" ]; then
	    echo "ERROR: X tics: ${x_tics} must be a positive integer."
	    exit 1
	fi
	if [ ${x_tics} -le 0 ];then
	    echo "ERROR: X tics: ${x_tics} must be a positive integer."
	    exti 1
	fi
    fi

    if [ "${y_tics}" != "" ];then
	is_integer ${y_tics}
	local is=${RETVAL}
	if [ "${is}" != "yes" ]; then
	    echo "ERROR: Y tics: ${y_tics} must be an integer >= 0."
	    exit 1
	fi
	if [ ${y_tics} -lt 0 ];then
	    echo "ERROR: Y tics: ${y_tics} must be an integer >= 0."
	    exit 1
	fi
    fi


    # yrange
    if [ "${y_range}" != "" ];then
	y_range_min=${y_range_array[0]}
	y_range_max=${y_range_array[1]}
	y_range_step=${y_range_array[2]}
	is_number ${y_range_min}
	local is=${RETVAL}
	if [ "${is}" == "no" ];then
	    echo "ERROR: in yrange: ${y_range}. ${y_range_min} is not a number."
	    exit 1
	fi
	is_number ${y_range_max}
	local is=${RETVAL}
	if [ "${is}" == "no" ];then
	    echo "ERROR: in yrange: ${y_range}. ${y_range_max} is not a number."
	    exit 1
	fi

	local isgt=`greater_than ${y_range_max} ${y_range_min}`
	if [ "${isgt}" == "0" ];then
	    echo "ERROR: in yrange:${y_range}. Should be ${y_range_max} > ${y_range_min}."
	    exit 1
	fi

	if [ "${y_range_step}" != "" ];then
	    if [ "${y_tics}" != "" ];then
		echo "ERROR: Conflicting options --ytics ${y_tics} and --yrange ${y_range}."
		exit 1
	    fi
	    is_number ${y_range_step}
	    local is=${RETVAL}
	    if [ "${is}" == "no" ];then
		echo "ERROR: in yrange: ${y_range}. ${y_range_step} is not a number."
		exit 1
	    fi
	fi
    fi

    # colors
    if [ "${user_colors}" != "" ];then
	set_ifs ","
	local color
	for color in ${user_colors}; do
	    local grepped_color=`echo ${color} | egrep -o "#[0-9a-fA-F][0-9a-fA-F][0-9a-fA-F][0-9a-fA-F][0-9a-fA-F][0-9a-fA-F]"`
	    if [ "${grepped_color}" != "${color}" ]; then
		echo "ERROR: in color ${color} of ${user_colors}."
		exit 1
	    fi
	done


	local x
	local xi=0
	for x in ${x_vals}; do
	    xi=$(($xi+1))
	done
	if [ ${xi} -gt ${#color_array[@]} ];then
	    echo "ERROR: Too few colors specified. At least ${xi} are required!"
	    exit 1
	fi

	reset_ifs
    fi

    # cluster gap
    if [ "${cluster_gap}" != "" ];then
	is_number ${cluster_gap}
	local is=${RETVAL}
	if [ "${is}" == "no" ];then
	    echo "ERROR: cluster gap: ${cluster_gap} must be a number!"
	    exit 1
	fi
	local isgt=`greater_than ${cluster_gap} 0`
	if [ "${isgt}" == "0" ];then
	    echo "ERROR: cluster gap: ${cluster_gap} must be a positive number!"
	    exit 1
	fi
    fi

    # xmap
    if [ "${x_map}" != "" ];then
	local i=0
	local maxi=${#x_map_array[@]}
	while [ ${i} -le ${maxi} ];do
	    local xbit=${x_map_array[${i}]}
	    if [ "${xbit}" != "1" ]&&[ "${xbit}" != "0" ];then
		echo "ERROR: in xmap: ${x_map}. The ${i}'th bit: ${xbit} must be 0 or 1."
		exit 1
	    fi
	done
    fi

    # ymap
    if [ "${y_map}" != "" ];then
	local i=0
	local maxi=${#y_map_array[@]}
	while [ ${i} -le ${maxi} ];do
	    local ybit=${y_map_array[${i}]}
	    if [ "${ybit}" != "1" ]&&[ "${ybit}" != "0" ];then
		echo "ERROR: in ymap: ${y_map}. The ${i}'th bit: ${ybit} must be 0 or 1."
		exit 1
	    fi
	done
    fi

   # xavg
    if [ "${x_avg}" != "" ];then
	local i=0
	local maxi=${#x_avg_array[@]}
	while [ ${i} -lt ${maxi} ];do
	    local x=${x_avg_array[${i}]}
	    is_integer ${y_tics}
	    local is=${RETVAL}
	    if [ "${is}" != "yes" ]; then
		echo "ERROR: in xavg: ${x_avg}. ${x} must be an integer."
		exit 1
	    fi
	    local min=0
	    local max=0
	    local xv
	    set_ifs ", "
	    for xv in ${x_vals};do
		max=$((${max} + 1))
	    done
	    reset_ifs

	    if [ ${x} -lt ${min} ]||[ ${x} -gt ${max} ];then
		echo "ERROR: in xavg: ${x_avg}. Must be: ${min} < ${x} < ${max}."
		exit 1
	    fi
	    i=$((${i} + 1))
	done
	avg_max_x=${maxi}
    fi

   # yavg
    if [ "${y_avg}" != "" ];then
	local i=0
	local maxi=${#y_avg_array[@]}
	while [ ${i} -lt ${maxi} ];do
	    local y=${y_avg_array[${i}]}
	    is_integer ${y_tics}
	    local is=${RETVAL}
	    if [ "${is}" != "yes" ]; then
		echo "ERROR: in yavg: ${y_avg}. ${y} must be an integer."
		exit 1
	    fi
	    local min=0
	    local max=0
	    local yv
	    set_ifs ", "
	    for yv in ${y_vals};do
	    	max=$((${max} + 1))
	    done
	    reset_ifs

	    if [ ${y} -lt ${min} ]||[ ${y} -gt ${max} ];then
	    	echo "ERROR: in yavg: ${y_avg}. Must be: ${min} < ${y} < ${max}."
	    	exit 1
	    fi
	    i=$((${i} + 1))
	done
	avg_max_y=${maxi}
    fi

    # bar width
    if [ "${bar_width}" != "" ];then
	is_number ${bar_width}
	local is=${RETVAL}
	if [ "${is}" == "no" ];then
	    echo "ERROR: bar width: ${bar_width} must be a number!"
	    exit 1
	fi
    else
	if [ "${plot_type}" == "stacked" ]; then
	    bar_width=0.6  		# Default bar width
	fi
    fi


    # line width
    if [ "${line_width}" != "" ];then
	is_number ${line_width}
	local is=${RETVAL}
	if [ "${is}" == "no" ];then
	    echo "ERROR: line width: ${line_width} must be a number!"
	    exit 1
	fi
    else
	line_width=3  		# Default line width
    fi

    # point size
    if [ "${point_size}" != "" ];then
	is_number ${point_size}
	local is=${RETVAL}
	if [ "${is}" == "no" ];then
	    echo "ERROR: point size: ${point_size} must be a number!"
	    exit 1
	fi
    else
	point_size=`echo "1 + ${line_width}/8" |bc -l` # Default point size
    fi

    # offsets
    if [ "${x_label_offset}" != "" ];then
	is_number ${x_label_offset}
	local is=${RETVAL}
	if [ "${is}" == "no" ];then
	    echo "ERROR: --xlabeloffset: ${x_label_offset} must be a number!"
	    exit 1
	fi
    fi
    if [ "${y_label_offset}" != "" ];then
	is_number ${y_label_offset}
	local is=${RETVAL}
	if [ "${is}" == "no" ];then
	    echo "ERROR: --ylabeloffset: ${y_label_offset} must be a number!"
	    exit 1
	fi
    fi
    if [ "${z_tags_offset}" != "" ];then
	is_number ${z_tags_offset}
	local is=${RETVAL}
	if [ "${is}" == "no" ];then
	    echo "ERROR: --ztagsoffset: ${z_tags_offset} must be a number!"
	    exit 1
	fi
    fi
    if [ "${out_format}" != "" ];then
	no_append="YES"
	case "${out_format}" in
	    "eps") gp_terminal_cmd="postscript eps enhanced color";suffix="eps";no_append="NO";;
	    "png") gp_terminal_cmd="png interlace truecolor enhanced crop";suffix="png";;
	    "jpeg") gp_terminal_cmd="jpeg interlace truecolor enhanced large";suffix="jpeg";;
	    *) echo "ERROR: --outformat: ${out_format}"; exit 1
	esac
    else
	gp_terminal_cmd="postscript eps enhanced color"
	suffix="eps"
    fi
}

# Return the directory for FILE_PATH
# For example if FILE_PATH is foo/bar/file.tar
# This function returns foo/bar/
get_dir()
{
    local file_path=${1}
    local fname=${file_path##*/}
    local dir=`echo ${file_path} | sed "s/${fname}$//"`
    RETVAL=${dir}
}

set_defaults()
{
    # set default size
    if [ "${size_param}" == "" ];then
	size_param_x=0.5
	size_param_y=0.5
    fi

    if [ "${epsfile}" == "" ];then
	epsfile="_moufoplot.${suffix}"
    fi

    # noappend
    if [ "${no_append}" != "YES" ];then
	no_append="NO"
    fi

    # If output file is in a directory which does not exist, create it
    get_dir ${epsfile}
    local dir=${RETVAL}
    if [ ! -d ${dir} ]; then
	print_msg "Directory ${dir} missing. Creating it..."
	mkdir -p ${dir}
    fi
}

get_normalize_values_nums()
{
    local ni
    local yn
    for yn in ${y_normv}; do
	is_number ${yn}
	local is=${RETVAL}
	if [ "${is}" == "no" ];then
	    echo "ERROR: -ynormv ${y_normv}: ${yn} must be a number!"
	    exit 1
	fi
	y_norm_array[${ni}]=${yn}
	ni=$((${ni} + 1))
    done
    local zn
    for zn in ${z_normv}; do
	is_number ${zn}
	local is=${RETVAL}
	if [ "${is}" == "no" ];then
	    echo "ERROR: -znormv ${z_normv}: ${zn} must be a number!"
	    exit 1
	fi
	z_norm_array[${ni}]=${zn}
	ni=$((${ni} + 1))
    done

}


# Read -xnorm and -ynorm filters and find the values that correspond to them
get_normalize_values()
{
    # If values are given, dont use filters
    if [ "$y_normv" != "" ]||[ "$x_normv" != "" ]||[ "${z_normv}" != "" ];then
	return
    fi

    # Normalize
    set_ifs ","
    print_msg "Getting X normalization values from filters... \n"
    local ni=0
    local xn
    for xn in ${x_norm};do
	get_match "${DIR}" "${xn} ${others}" "get_normalize_values X" "1"
	local xnorm_val=${RETVAL}
	x_norm_array[${ni}]=${xnorm_val}
	ni=$((ni + 1))
    done

    local xi=0
    local x
    for x in ${x_vals};do
	if [ "${x_norm_array[${xi}]}" == "" ];then
	    x_norm_array[${xi}]=${x_norm_array[0]}
	fi
	xi=$((xi + 1))
    done
    
    print_msg "Done!\n"
    print_msg "X norm values: ${x_norm_array[@]}"
    print_msg "\n"

    print_msg "Getting Y normalization values from filters... \n"
    local ni=0
    local yn
    for yn in ${y_norm};do
	get_match "${DIR}" "${yn} ${others}" "get_normalize_values Y"
	local ynorm_val=${RETVAL}
	y_norm_array[${ni}]=${ynorm_val}
	ni=$((ni + 1))
    done

    local yi=0
    local y
    for y in ${y_vals};do
	if [ "${y_norm_array[${yi}]}" == "" ];then
	    y_norm_array[${yi}]=${y_norm_array[0]}
	fi
	yi=$((yi + 1))
    done
    print_msg "Done!\n"
    print_msg "Y norm values: ${y_norm_array[@]}"
    print_msg "\n"


    print_msg "Getting Z normalization values from filters... \n"
    local ni=0
    local zn
    for zn in ${z_norm};do
	get_match "${DIR}" "${zn} ${others}" "get_normalize_values Z"
	local znorm_val=${RETVAL}
	z_norm_array[${ni}]=${znorm_val}
	ni=$((ni + 1))
    done

    local zi=0
    local z
    for z in ${z_vals};do
	if [ "${z_norm_array[${zi}]}" == "" ];then
	    z_norm_array[${zi}]=${z_norm_array[0]}
	fi
	zi=$((zi + 1))
    done
    print_msg "Done!\n"
    print_msg "Z norm values: ${z_norm_array[@]}"
    print_msg "\n"
    reset_ifs

}

parse_legend()
{
    local ON=0
    local OFF=1
    local OUT=2
    local IN=3
    local TOP=4
    local BOTTOM=5
    local CENTER=6
    local RIGHT=7
    local LEFT=8
    local VERTICAL=9
    local HORIZONTAL=10
    local BOX=11
    local NOBOX=12
    local LJUST=13
    local RJUST=14
    local SMALL=15
    local AT=16

    # Default values:
    if [ "${plot_type}" == "stacked" ];then
	key_command="set key rmargin"
    fi

    if [ "${legend_params}" == "" ];then
	if [ "${key_command}" != "" ];then
	    return
	fi
    fi
    
    set_ifs ","
    local mask
    local p
    for p in ${legend_params}; do
	case "${p}" in
	    "on") mask[${ON}]=1;;
	    "off") mask[${OFF}]=1;;
	    "out") mask[${OUT}]=1;;
	    "in") mask[${IN}]=1;;
	    "top") mask[${TOP}]=1;;
	    "bottom") mask[${BOTTOM}]=1;;
	    "center") mask[${CENTER}]=1;;
	    "right") mask[${RIGHT}]=1;;
	    "left") mask[${LEFT}]=1;;
	    "vertical") mask[${VERTICAL}]=1;;
	    "horizontal") mask[${HORIZONTAL}]=1;;
	    "box") mask[${BOX}]=1;;
	    "nobox") mask[${NOBOX}]=1;;
	    "ljust") mask[${LJUST}]=1;;
	    "rjust") mask[${RJUST}]=1;;
	    "small") mask[${SMALL}]=1;;
	    *) 
		local atgrep=`echo ${p}|egrep -o "at(([0-9]+)|([0-9]+\.[0-9]+))x(([0-9]+)|([0-9]+\.[0-9]+))"`
		if [ "${p}" == "${atgrep}" ]; then
		    local atcoord=`echo ${atgrep}|sed 's/at//'|sed 's/x/,/'`
		    mask[${AT}]=1
		else
		    echo "Unknown legend option: ${p}"
		    exit 1
		fi
	esac
    done
    reset_ifs

    if [ "${legend_params}" != "" ];then
	mask[${ON}]=1
    fi

    local key_default="set key inside top"
    local key_start="set key samplen 1"
    key_command=${key_start}
    if [ "${mask[${OFF}]}" == "1" ];then
	key_command="${key_command} off"
    else

	# Exclusive options
	if [ "${mask[${OUT}]}" == "1" ]&&[ "${mask[${IN}]}" == "1" ];then
	    echo "ERROR: Both in,out enabled!"
	    exit 1
	fi
	if [ "${mask[${TOP}]}" == "1" ]&&[ "${mask[${BOTTOM}]}" == "1" ];then
	    echo "ERROR: Both top,bottom enabled!"
	    exit 1
	fi
	if [ "${mask[${RIGHT}]}" == "1" ]&&[ "${mask[${LEFT}]}" == "1" ];then
	    echo "ERROR: Both right,left enabled!"
	    exit 1
	fi
	if [ "${mask[${VERTICAL}]}" == "1" ]&&[ "${mask[${HORIZONTAL}]}" == "1" ];then
	    echo "ERROR: Both vertical,horizontal enabled!"
	    exit 1
	fi
	if [ "${mask[${BOX}]}" == "1" ]&&[ "${mask[${NOBOX}]}" == "1" ];then
	    echo "ERROR: Both box,nobox enabled!"
	    exit 1
	fi


	# Position
	if [ "${mask[${AT}]}" == "1" ];then
	    key_command="${key_command} at ${atcoord}"
	fi


	if [ "${mask[${IN}]}" == "1" ];then
	    key_command="${key_command} inside"
	fi
	if [ "${mask[${OUT}]}" == "1" ];then
	    key_command="${key_command} outside"
	fi


	if [ "${mask[${TOP}]}" == "1" ];then
	    key_command="${key_command} top"
	fi
	if [ "${mask[${BOTTOM}]}" == "1" ];then
	    key_command="${key_command} bottom"
	fi
	if [ "${mask[${CENTER}]}" == "1" ];then
	    key_command="${key_command} center"
	fi


	if [ "${mask[${LEFT}]}" == "1" ];then
	    key_command="${key_command} lmargin"
	fi
	if [ "${mask[${RIGHT}]}" == "1" ];then
	    key_command="${key_command} rmargin"
	fi

	# Sample size
	if [ "${mask[${SMALL}]}" == "1" ];then
	    key_command="${key_command} samplen 1"
	fi





	# Justification
	if [ "${mask[${LJUST}]}" == "1" ];then
	    key_command="${key_command} Left"
	fi
	if [ "${mask[${RJUST}]}" == "1" ];then
	    key_command="${key_command} Right"
	fi



	# Default 
	if [ "${key_command}" == "${key_start}" ];then
	    key_command=${key_default}
	fi


	# Vertical-Horizontal (optional)
	if [ "${mask[${VERTICAL}]}" == "1" ];then
	    key_command="${key_command} vertical"
	fi
	if [ "${mask[${HORIZONTAL}]}" == "1" ];then
	    key_command="${key_command} horizontal"
	fi


	# Box/Nobox
	if [ "${mask[${BOX}]}" == "1" ];then
	    key_command="${key_command} box"
	fi
	if [ "${mask[${NOBOX}]}" == "1" ];then
	    key_command="${key_command} nobox"
	fi


    fi
    print_msg "Legend: ${key_command}\n"
}


get_max_xtag_len()
{
    set_ifs ","
    local max_xlen=0
    if [ "${xtags_array}" == "" ];then
	for x in ${y_vals}; do
	    local xlen=`echo ${x} | wc -c`
	    if [ ${xlen} -gt ${max_xlen} ];then
		max_xlen=${xlen}
	    fi
	done
    else
	for x in ${y_tags}; do
	    local xlen=`echo ${x} | wc -c`
	    if [ ${xlen} -gt ${max_xlen} ];then
		max_xlen=${xlen}
	    fi
	done
    fi
    RETVAL=${max_xlen}
    reset_ifs
}

parse_xyrotate()
{
    if [ "${x_tics_rotate}" == "" ];then
	get_max_xtag_len
	local xtag_len=${RETVAL}

	if [ ${xtag_len} -le 3 ];then
	    x_tics_rotate=0
	else
	    x_tics_rotate=-90
	fi
    fi

    if [ "${y_tics_rotate}" == "" ];then
	y_tics_rotate=0
    fi
}

parse_size()
{
    if [ "${size_param}" != "" ]; then
	set_ifs "xX"
	local s
	local si=0
	local size_array
	for s in ${size_param};do
	    size_array[${si}]=${s}
	    si=$((si + 1))
	done
	reset_ifs
	if [ ${si} -gt 2 ]||[ "${size_array[0]}" == "" ]||[ "${size_array[1]}" == "" ]; then
	    echo "ERROR: parsing size parameter: ${size_param}. Must be: NUMxNUM."
	    exit 1
	fi
	size_param_x=${size_array[0]}
	size_param_y=${size_array[1]}
    else
	size_param_x=0.5
	size_param_y=0.55
    fi
}

parse_yrange()
{
    if [ "${y_range}" != "" ];then
	local ni=0
	set_ifs ","
	for num in ${y_range}; do
	    y_range_array[${ni}]=${num}
	    ni=$(($ni + 1))
	done
	reset_ifs
	if [ ${ni} -lt 2 ];then
	    echo "ERROR: yrange: ${y_range} should be a pair: num1,num2"
	    exit 1
	fi
    fi
}

parse_colors()
{
    if [ "${user_colors}" == "" ];then
	color_array[0]="#000000" #(black)
	color_array[1]="#000000" #(black)
	color_array[2]="#202000" # black
	color_array[3]="#ccaa00" # light yellow
	color_array[4]="#0000AA" # dark blue
	color_array[5]="#00BB00" # light green
	color_array[6]="#ffdb66" # light yellow
	color_array[7]="#AA0000" # red
	color_array[8]="#6699ff" # light blue
	color_array[9]="#7b5b46" # brown


	# color_array[8]="#887700" # light orange
	# color_array[9]="#11e7c1" # light green

	# color_array[9]="#c900c9" # light purple
	color_array[10]="#006f00" # dark orange
	color_array[12]="#5c5a4d" # grey
	color_array[11]="#dddddd"

	color_array[13]="#00ff00"
	color_array[14]="#00ffff"
	color_array[15]="#ff0000"
	color_array[16]="#ff00ff"
	color_array[17]="ffff00"
        # dark blue, light orange, dark green, light pink, dark brown, light grey
        #color_array=("#000066" "#ffcc00" "#336600" "#ff66ff" "#660000" "#999999")
    else
	set_ifs ","
	local i=2
	for c in ${user_colors}; do
	    color_array[${i}]="${c}"
	    i=$((i + 1))
	done
	reset_ifs
    fi
}

parse_xmask()
{
    if [ "${x_mask}" != "" ];then
	local x
	local i=0
	set_ifs ", "
	for x in ${x_mask}; do
	    x_mask_array[${i}]=${x}
	    i=$(($i + 1))
	done
	reset_ifs
    fi
}

parse_ymask()
{
    if [ "${y_mask}" != "" ];then
	local y
	local i=0
	set_ifs ", "
	for y in ${y_mask}; do
	    y_mask_array[${i}]=${y}
	    i=$(($i + 1))
	done
	reset_ifs
    fi
}

parse_zmask()
{
    if [ "${z_mask}" != "" ];then
	local z
	local i=0
	set_ifs ", "
	for z in ${z_mask}; do
	    z_mask_array[${i}]=${z}
	    i=$(($i + 1))
	done
	reset_ifs
    fi
}

parse_pnttype()
{
    if [ "${point_type}" != "" ];then
	local p
	local i=0
	set_ifs ", "
	for p in ${point_type}; do
	    is_number ${p}
	    local is=${RETVAL}
	    if [ "${is}" == "no" ];then
		echo "ERROR: --pnttype ${point_type}: ${p} must be a number!"
		exit 1
	    fi
	    point_type_array[${i}]=${p}
	    i=$(($i + 1))
	done
	reset_ifs
    else
	# Set default value
	local i=0;
	while [ ${i} -lt $((${max_x} + 1)) ]; do
	    point_type_array[${i}]=${i}
	    i=$((i + 1))
	done
    fi
}


parse_linetype()
{
    if [ "${line_type}" != "" ];then
	local lt
	local i=0
	set_ifs ", "
	for lt in ${line_type}; do
	    is_number ${lt}
	    local is=${RETVAL}
	    if [ "${is}" == "no" ];then
		echo "ERROR: --linetype ${line_type}: ${lt} must be a number!"
		exit 1
	    fi
	    line_type_array[${i}]=${lt}
	    i=$(($i + 1))
	done
	reset_ifs
    else
	# Set default value
	local i=0;
	while [ ${i} -lt $((${max_x} + 1)) ]; do
	    line_type_array[${i}]=1
	    i=$((i + 1))
	done
    fi
}

parse_xavg()
{
    if [ "${x_avg}" != "" ];then
	local x
	local i=0
	set_ifs ", "
	for x in ${x_avg}; do
	    x_avg_array[${i}]=${x}
	    i=$(($i + 1))
	done
	reset_ifs
    fi
}

parse_yavg()
{
    if [ "${y_avg}" != "" ];then
	local y
	local i=0
	set_ifs ", "
	for y in ${y_avg}; do
	    y_avg_array[${i}]=${y}
	    i=$(($i + 1))
	done
	reset_ifs
    fi
}

parse_percent() 		# Must run before parse_legend
{
    if [ "${percent}" != "" ];then
	if [ "${y_format}" == "" ];then
	    y_format="%.0f%%"
	fi
	if [ "${y_range}" == "" ];then
	    y_range="0,100,10"
	fi
	key_command="set key rmargin"
    fi
}

parse_yformat()			# After parse_percent
{
    if [ "${y_format}" == "" ];then
	y_format="%4.2f"
    fi
}

parse_offsets()
{
    if [ "${x_label_offset}" == "" ];then
	x_label_offset=-0.8
    fi

    if [ "${y_label_offset}" == "" ];then
	y_label_offset=0
    fi

    if [ "${z_tags_offset}" == "" ];then
	z_tags_offset=`echo "- ${x_label_offset}/2" |bc -l`
	z_tags_offset="0${z_tags_offset}" # leading 0 hack
    fi
}

# Remove unwanted characters from tags like: '_' ' ' etc.
fix_tags()
{
    local csv=${1}
    local value
    local csv_fixed
    set_ifs ","
    for value in ${csv}; do
	local value_fixed=`echo ${value}|sed 's/ /-/g' | sed 's/_/-/g'`
	csv_fixed="${csv_fixed},${value_fixed}"
    done
    reset_ifs
    csv_fixed=`echo ${csv_fixed} | sed 's/.\(.*\)/\1/'`
    RETVAL=${csv_fixed}
}

parse_tags()
{
    # Custom Labels (TAGS)
    set_ifs ","
    local xi=0
    local x
    if [ "${x_tags}" == "" ]; then
	x_tags=${x_vals}
    fi
    for x in ${x_tags}; do
	fix_tags "${x}"		# Remove spaces, underscores
	xtags_array[${xi}]="${RETVAL}"
	xi=$((xi+1))
    done


    local yi=0
    local y
    if [ "${y_tags}" == "" ]; then
	y_tags=${y_vals}
    fi
    for y in ${y_tags}; do
	fix_tags "${y}"		# Remove spaces, underscores
	ytags_array[${yi}]="${RETVAL}"
	yi=$((yi + 1))
    done


    local zi=0
    local z
    if [ "${z_tags}" == "" ]; then
	z_tags=${z_vals}
    fi
    for z in ${z_tags}; do
	fix_tags "${z}"		# Remove spaces, underscores
	ztags_array[${zi}]="${RETVAL}"
	zi=$((zi + 1))
    done
    reset_ifs
}

parse_vals()
{
    # Reverse x, y
    # if [ "${plot_type}" == "bargraph" ] \
    # 	|| [ "${plot_type}" == "stacked" ] \
    # 	|| [ "${plot_type}" == "linegraph" ];then
    # 	if [ "${y_vals}" != "" ];then
	    # local x_vals_sv=${x_vals}
	    # x_vals=${y_vals}
	    # y_vals=${x_vals_sv}
    # 	fi
    # fi


    # Support -x @ / -y @ / -z @ 
    # NOTE: -x * looks tempting but bash expands it, so -x "*" should be used 
    #       this could lead to hard-to-spot errors
    if [ "${x_vals}" == "@" ];then
	get_all ${DIR}
	x_array=${RETVAL}
	x_vals=${RETVAL}
    else
	x_array=${x_vals}
    fi
    if [ "${y_vals}" == "@" ];then
	get_all ${DIR}
	y_array=${RETVAL}
	y_vals=${RETVAL}
    else
	y_array=${y_vals}
    fi
    if [ "${z_vals}" == "@" ];then
	get_all ${DIR}
	z_array=${RETVAL}
	z_vals=${RETVAL}
    else
	z_array=${z_vals}
    fi



    if [ "${z_array}" == "" ];then
	z_array="NO-ZAXIS"
	no_z=1
    fi
    if [ "${y_array}" == "" ];then
	y_array="NO-YAXIS"
	no_y=1
    fi
    if [ "${x_array}" == "" ];then
	x_array="NO-XAXIS"
	no_x=1
    fi

}

# Display a waiting bar /-\
wait_cnt=0
wait_bar()
{
    # Wait print throttling
    if [ ${wait_cnt} -lt 20 ]; then
	wait_cnt=$((${wait_cnt} + 1))
	return;
    else
	wait_cnt=0
    fi


    if [ ! ${wait_bar_i} ]; then
	wait_bar_i=0
	print_msg "-"
    fi

    if [ $((${wait_bar_i} % 3)) -eq 0 ]; then
	print_msg "\b/"
    elif [ $((${wait_bar_i} % 3)) -eq 1 ]; then
	print_msg "\b-"
    elif [ $((${wait_bar_i} % 3)) -eq 2 ]; then
	print_msg "\b/"
    fi
    wait_bar_i=$((${wait_bar_i} + 1))
}


# Read data from INPUT_FILE starting from STRING_START up to STRING_STOP and 
# dump it to OUTPUT_FILE
restore_data()
{
    local input_file=${1}
    local string_start=${2}
    local string_stop=${3}
    local output_file=${4}

    local TMPDIR="/tmp/moufoplot.data.tmp"
    cat ${input_file} | grep "%%" > ${TMPDIR}
    # echo "" > ${output_file}
    if [ -f "${output_file}" ];then
	echo "Removing ${output_file}"
	rm ${output_file}
    fi
    local parse_line=0
    printf "Restoring data... \n"
    while read line; do
	wait_bar
        # echo ${line}
	echo ${line}|grep "${string_stop}" > /dev/null
	if [ ${?} -eq 0 ]; then
		# echo "END PARSING"
	    parse_line=0
	fi 
	if [ ${parse_line} -eq 1 ]; then
		# echo "DUMPING"
	    local newline=`echo -e "${line}\n"|sed 's/%//g'`
	    # Only write to output if non-empty
	    if [ `echo ${newline} | wc -w` -gt 0 ]; then
		echo ${newline} >> ${output_file}
	    fi 
	fi
	echo ${line}|grep "${string_start}" > /dev/null
	if [ ${?} -eq 0 ]; then
		# echo "START PARSING"
	    parse_line=1
	fi 
    done < ${TMPDIR}
    print_msg "\bDONE\n"

    # Sanity check. Check if the data file is empty
    if [ ! -f ${output_file} ]; then
	echo "No data to restore"
	exit 1
    fi
    local data_size=`cat ${output_file} | wc -c`
    if [ ! ${?} -eq 0 ]||[ ${data_size} -eq 0 ]; then
	echo "Hmm... Sanity check for ${output_file} failed."
	exit 1
    fi
}

parse_arguments()
{
    local short_args="hd:x:y:z:f:t:c:iv"
    local long_args="help,bar,hmap,line,stack,dir:,xvals:,yvals:,zvals:,filter:,\
title:,xlabel:,ylabel:,data:,xtags:,noxtags,ytags:,noytags,ztags:,noztags,\
xnorm:,ynorm:,znorm:,xnormv:,ynormv:,znormv:,xrotate:,yrotate:,\
legend:,size:,xformat:,yformat:,ytics:,yrange:,colors:,ignore,gap:,xmask:,ymask:,\
zmask:,xavg:,yavg:,percent,barw:,linew:,linetype:,pntsize:,pnttype:,noviewer,forceviewer,viewer:,xlabeloffset:,\
ylabeloffset:,ztagsoffset:,gp:,out:,zlabel:,noappend,outformat:,silent,version,regen:,xgeo,ygeo"
    local getoptcmd="getopt -a -o ${short_args} -l ${long_args} -n getopt.sh -- ${@}"
    local getoptcmd_set_args="local args=\`${getoptcmd}\`"
    # echo "GETOPT: $getoptcmd_set_args"
    eval $getoptcmd_set_args > /dev/null
    local args_array=($args)
    # getopt -q -o "${short_args}" -l "${long_args}" -n "getopt.sh" -- "$@"
    # eval "getopt -a -Q -q -o ${short_args} -l ${long_args} -n getopt.sh -- $@" > /dev/null
    eval "${getoptcmd}" > /dev/null

    if [ $? != 0 ]||[ "${args_array[0]}" == "--" ] ;then
	echo "Bad argument(s), printing help and exiting."
	usage
	exit 1
    fi


    eval set -- "$args"
    while true; do

	local saved_1=${1}
	local saved_2=${2}
	case "$1" in
	    "--dir"|"-dir"|"-d") DIR="$2";shift;;
	    "--xvals"|"-xvals"|"-x") x_vals="$2";shift;;
	    "--yvals"|"-yvals"|"-y") y_vals="$2";shift;;
	    "--zvals"|"-zvals"|"-z") z_vals="$2";shift;;
	    "--filter"|"-filter"|"-f") others="$2";shift;;
	    "--title"|"-title"|"-t") title="$2";shift;;
	    "--xtags"|"-xtags") x_tags="$2";shift;;
	    "--noxtags"|"-noxtags") nox_tags="YES";;
	    "--ytags"|"-ytags") y_tags="$2";shift;;
	    "--noytags"|"-noytags") noy_tags="YES";;
	    "--ztags"|"-ztags") z_tags="$2";shift;;
	    "--noztags"|"-noztags") noz_tags="YES";;
	    "--xlabel"|"-xlabel") x_title="$2";shift;;
	    "--xlabeloffset"|"-xlabeloffset") x_label_offset="$2";shift;;
	    "--ylabel"|"-ylabel") y_title="$2";shift;;
	    "--ylabeloffset"|"-ylabeloffset") y_label_offset="$2";shift;;
	    "--zlabel"|"-zlabel") z_label="$2";shift;;
	    "--ztagsoffset"|"-ztagsoffset") z_tags_offset="$2";shift;;
	    "--help"|"-help"|"-h") usage; exit 1;;
	    "--bar"|"-bar") plot_type="bargraph";;
	    "--hmap"|"-hmap") plot_type="heatmap";;
	    "--line"|"-line") plot_type="linegraph";;
	    "--stack"|"-stack") plot_type="stacked";;
	    "--xnorm"|"-xnorm") x_norm="$2";shift;;
	    "--ynorm"|"-ynorm") y_norm="$2";shift;;
	    "--znorm"|"-znorm") z_norm="$2";shift;;
	    "--xnormv"|"-xnormv") x_normv="$2";shift;;
	    "--ynormv"|"-ynormv") y_normv="$2";shift;;
	    "--znormv"|"-znormv") z_normv="$2";shift;;
	    "--xrotate"|"-xrotate") x_tics_rotate="$2";shift;;
	    "--yrotate"|"-yrotate") y_tics_rotate="$2";shift;;
	    "--legend"|"-legend") legend_params="$2";shift;;
	    "--size"|"-size") size_param="$2";shift;;
	    "--xformat"|"-xformat") x_format="$2";shift;;
	    "--yformat"|"-yformat") y_format="$2";shift;;
	    "--ytics"|"-ytics") y_tics="$2";shift;;
	    "--yrange"|"-yrange") y_range="$2";shift;;
	    "--colors"|"-colors"|"-c") user_colors="$2";shift;;
	    "--ignore"|"-ignore"|"-i") ignore_filter="YES";;
	    "--gap"|"-gap") cluster_gap="$2";shift;;
	    "--xmask"|"-xmask") x_mask="$2";shift;;
	    "--ymask"|"-ymask") y_mask="$2";shift;;
	    "--zmask"|"-zmask") z_mask="$2";shift;;
	    "--xavg"|"-xavg") x_avg="$2";shift;;
	    "--yavg"|"-yavg") y_avg="$2";shift;;
	    "--xgeo"|"-xgeo") x_geomean_flag="YES";;
	    "--ygeo"|"-ygeo") y_geomean_flag="YES";;
	    "--percent"|"-percent") percent="YES";;
	    "--barw"|"-barw") bar_width="$2";shift;;
	    "--linew"|"-linew") line_width="$2";shift;;
	    "--linetype"|"-linetype") line_type="$2";shift;;
	    "--pntsize"|"-pntsize") point_size="$2";shift;;
	    "--pnttype"|"-pnttype") point_type="$2";shift;;
	    "--noviewer"|"-noviewer") no_viewer="YES";;
	    "--forceviewer"|"-forceviewer") no_viewer="NO";;
	    "--viewer"|"-viewer") eps_viewer="$2";shift;;
	    "--data"|"-data") data_file="$2";shift;;
	    "--gp"|"-gp") gpfname="$2";shift;;
	    "--out"|"-out") epsfile="$2";shift;;
	    "--noappend"|"-noappend") no_append="YES";;
	    "--outformat"|"-outformat") out_format="$2";shift;;
	    "--silent"|"-silent") silent="YES";;
	    "--regen"|"-regen") regen="$2";shift;;
	    "--version"|"-version"|"-v") version; exit 0;;
	    "--") break;
	esac

	# If shifted then $1 == saved_2
	if [ "${1}" == "${saved_2}" ]&&[ "${1}" != "${saved_1}" ];then
	    # The argument requires 2 parts, save them both
	    arguments_saved="${arguments_saved} ${saved_1} \"${saved_2}\""
	else
	    # The argument only has 1 part
	    arguments_saved="${arguments_saved} ${saved_1}"
	fi

	shift
    done

    if [ "${data_file}" == "" ];then
	data_file="/tmp/moufoplot.data"
    fi


    # If we are regenerating a .eps file, then use the data points from it
    if [ ! ${IGNORE_REGEN} ]&&[ ${regen} ];then
	if [ ! -f ${regen} ];then
	    echo "ERROR: Regen file: ${PWD}/${regen} does not exist. Check the file path."
	    exit 1
	fi
	# echo "Early exit..."
	return
    fi

    # DIR
    if [ "${DIR}" == "" ];then
	print_err "ERROR: No data selected! Please specify with -d / --dir.\n"
	exit 1
    fi



    # Check if plot type is not set. If so default to bargraph
    if [ "${plot_type}" == "" ];then
	plot_type="bargraph"
    fi

    parse_vals
    calculate_max_xyz		# Initial calculation (without avg)

    parse_tags

    parse_xyrotate		# After parse_tags, parse_vals

    parse_percent 		# Must run before parse_legend
    parse_yformat		# After parse_percent

    # Parse Legend parameters
    parse_legend
    if [ $? -ne 0 ]; then exit 1; fi    

    # Parse Size parameter
    parse_size
    if [ $? -ne 0 ]; then exit 1; fi    

    parse_colors
    if [ $? -ne 0 ]; then exit 1; fi    

    get_normalize_values_nums
    if [ $? -ne 0 ]; then exit 1; fi
    get_normalize_values
    if [ $? -ne 0 ]; then exit 1; fi

    parse_xmask
    if [ $? -ne 0 ]; then exit 1; fi

    parse_ymask
    if [ $? -ne 0 ]; then exit 1; fi

    parse_linetype
    if [ $? -ne 0 ]; then exit 1; fi

    parse_pnttype
    if [ $? -ne 0 ]; then exit 1; fi

    parse_xavg
    if [ $? -ne 0 ]; then exit 1; fi

    parse_yavg
    if [ $? -ne 0 ]; then exit 1; fi

    parse_yrange
    if [ $? -ne 0 ]; then exit 1; fi    

    parse_offsets

    if [ "${y_tics}" == "" ]&&[ "${y_range}" == "" ];then
	y_tics=5
    fi

    print_msg "+--------------------------------+\n"
    print_msg "|         MoufoPlot %4s         |\n" "${moufoplot_version}"
    print_msg "+--------------------------------+\n"
    print_msg "| COMMAND LINE OPTIONS:\n"
    print_msg "| Type: ${plot_type}\n"
    print_msg "| DIR/FILE: ${DIR}\n"
    print_msg "| x: ${x_vals}\n"
    print_msg "| y: ${y_vals}\n"
    print_msg "| z: ${z_vals}\n"
    print_msg "| filter: ${others}\n"
    print_msg "| title: ${title}\n"
    print_msg "| xlabel: ${x_title}\n"
    print_msg "| xlabel offset: ${x_label_offset}\n"
    print_msg "| ylabel: ${y_title}\n"
    print_msg "| ylabel offset: ${y_label_offset}\n"
    print_msg "| zlabel: ${z_label}\n"
    print_msg "| xtags: ${x_tags}\n"
    print_msg "| noxtags: ${nox_tags}\n"
    print_msg "| ytags: ${y_tags}\n"
    print_msg "| noytags: ${noy_tags}\n"
    print_msg "| ztags: ${z_tags}\n"
    print_msg "| noztags: ${noz_tags}\n"
    print_msg "| ztagsoffset: ${z_tags_offset}\n"
    print_msg "| x norm filters: ${x_norm}\n"
    print_msg "| y norm filters: ${y_norm}\n"
    print_msg "| z norm filters: ${z_norm}\n"
    print_msg "| y norm values: ${y_normv}\n"
    print_msg "| x tags rotate: ${x_tics_rotate}\n"
    print_msg "| y tags rotate: ${y_tics_rotate}\n"
    print_msg "| Legend: ${legend_params}\n"
    print_msg "| Size: ${size_param}\n"
    print_msg "| Xformat: ${x_format}\n"
    print_msg "| Yformat: ${y_format}\n"
    print_msg "| Ytics: ${y_tics}\n"
    print_msg "| Yrange: ${y_range}\n"
    print_msg "| Colors: ${user_colors}\n"
    print_msg "| Ignore Filter ERROR: ${ignore_filter}\n"
    print_msg "| Cluster GAP: ${cluster_gap}\n"

    local xmk
    local xmi=0
    print_msg "|        "
    for xmk in ${x_mask};do
	print_msg "%1d " ${xmi}
	xmi=$((${xmi}+1))
	if [ ${xmi} -eq 10 ];then
	    xmi=0
	fi
    done
    print_msg "\n"
    print_msg "| xmask: ${x_mask}\n"

    local ymk
    local ymi=0
    print_msg "|        "
    for ymk in ${y_mask};do
	print_msg "%1d " ${ymi}
	ymi=$((${ymi}+1))
	if [ ${ymi} -eq 10 ];then
	    ymi=0
	fi
    done
    print_msg "\n"
    print_msg "| ymask: ${y_mask}\n"

    local zmk
    local zmi=0
    print_msg "|        "
    for zmk in ${z_mask};do
	print_msg "%1d " ${zmi}
	zmi=$((${zmi}+1))
	if [ ${zmi} -eq 10 ];then
	    zmi=0
	fi
    done
    print_msg "\n"
    print_msg "| zmask: ${z_mask}\n"


    if [ "${gpfname}" == "" ];then
	gpfname="/tmp/moufoplot.gp"
    fi
    # rm ${gpfname}

    print_msg "| xavg: ${x_avg}\n"
    print_msg "| yavg: ${y_avg}\n"
    print_msg "| xgeo: ${x_geomean_flag}\n"
    print_msg "| ygeo: ${y_geomean_flag}\n"
    print_msg "| percent: ${percent}\n"
    print_msg "| bar width: ${bar_width}\n"
    print_msg "| line width: ${line_width}\n"
    print_msg "| line type: ${line_type}\n"
    print_msg "| point size: ${point_size}\n"
    print_msg "| point type: ${point_type}\n"
    print_msg "| bar line width: ${bar_line_width}\n"
    print_msg "| .data file: ${data_file}\n"
    print_msg "| .gp   file: ${gpfname}\n"
    print_msg "| output file: ${epsfile}\n"
    print_msg "| Dont append data to eps: ${no_append}\n"
    print_msg "| noviewer: ${no_viewer}\n"
    print_msg "| forceviewer: ${no_viewer}\n"
    print_msg "| viewer: ${eps_viewer}\n"
    print_msg "| outformat: ${out_format}\n"
    print_msg "| silent: ${silent}\n"
    print_msg "| regen: ${regen}\n"
    print_msg "+-------------------------------+\n"

}

version()
{
    # local script_name=${0##*/}
    echo "${MOUFOPLOT_STRING} ${moufoplot_version}"
}

usage()
{
    version
    print_msg "Usage: ${script_name} <OPTIONS>\n"
    print_msg "   --bar                        : (DEF) Generate histograms.\n"
    print_msg "   --stack                      : Generate stacked histograms.\n"
    print_msg "   --line                       : Generate line-graphs.\n"
    print_msg "   --hmap                       : Generate heat-map graphs.\n"
    print_msg "   --dir,-d \"<DIR/FILE>\"      : File or Directory of input data.\n"
    print_msg "   --xvals,-x \"<x values>\"    : The identifiers of the X values.\n"
    print_msg "   --yvals,-y \"<y values>\"    : The identifiers of the Y values.\n"
    print_msg "   --zvals,-z \"<z values>\"    : The identifiers of the Z values.\n"
    print_msg "   --filter,-f \"<filter vals>\": The filtering identifiers.\n"
    print_msg "   --title, -t \"<title>\"      : (Opt) Graph title.\n"
    print_msg "   --xlabel \"<x label>\"       : (Opt) Label of the X axis.\n"
    print_msg "   --xlabeloffset <xlabel offset>: (Opt) Set the offset of xlabel.\n"
    print_msg "   --ylabel \"<y label>\"       : (Opt) Label of the Y axis.\n"
    print_msg "   --ylabeloffset <ylabel offset>: (Opt) Set the offset of ylabel.\n"
    print_msg "   --zlabel \"<z label>\"       : (Opt) Label of the Z axis.\n"
    print_msg "   --data \"<file path>\"       : (Opt) .data data file.\n"
    print_msg "   --gp \"<file path>\"         : (Opt) .gp gnuplot file.\n"
    print_msg "   --out \"<file path>\"        : (Opt) Output postscript file.\n"
    print_msg "   --xtags \"<tags>\"           : (Opt) Tags for the X axis.\n"
    print_msg "   --noxtags                    : (Opt) Disable X axis tags.\n"
    print_msg "   --ytags \"<tags>\"           : (Opt) Tags for the Y axis.\n"
    print_msg "   --noytags                    : (Opt) Disable Y axis tags.\n"
    print_msg "   --ztags \"<tags>\"           : (Opt) Tags for the Z axis.\n"
    print_msg "   --noztags                    : (Opt) Disable Z axis tags.\n"
    print_msg "   --ztagsoffset <ztags offset> : (Opt) Set the offset of z tags.\n"
    print_msg "   --xnorm \"<x norm filters>\" : (Opt) Normalization filter X.\n"
    print_msg "   --ynorm \"<y norm filters>\" : (Opt) Normalization filter Y.\n"
    print_msg "   --znorm \"<z norm filters>\" : (Opt) Normalization filter Z.\n"
    print_msg "   --ynormv \"<y norm values>\" : (Opt) Normalization values Y.\n"
    print_msg "   --znormv \"<z norm values>\" : (Opt) Normalization values Z.\n"
    print_msg "   --xrotate \"<angle>\"        : (Opt) Rotate angle for X tags.\n"
    print_msg "   --yrotate \"<angle>\"        : (Opt) Rotate angle for Y tags.\n"
    print_msg "   --legend \"<parameters>\"    : (Opt) Control legend attrib.\n"
    print_msg "         Params: on/off, in/out, top/bottom/center, right/left,\n"
    print_msg "                 horizontal/vertical, ljust,rjust, small, box, atMxN\n"
    print_msg "   --size NUMxNUM               : (Opt) Dimensions of the graph.\n"
    print_msg "   --xformat \"format\"         : (Opt) Format of the x tags.\n"
    print_msg "   --yformat \"format\"         : (Opt) Format of the y tags.\n"
    print_msg "   --ytics NUM                  : (Opt) Number of tics on Y.\n"
    print_msg "   --yrange MIN,MAX,STEP        : (Opt) Range of Y tics.\n"
    print_msg "   --colors,-c \"#color1,#color2...\": (Opt) User defined colors USE:\"quotes\".\n"
    print_msg "   --gap <number>               : (Opt) The gap between clusters.\n"
    print_msg "   --xmask <bitmap>             : (Opt) Disable X bars with 0.\n"
    print_msg "   --ymask <bitmap>             : (Opt) Disable Y bars with 0.\n"
    print_msg "   --zmask <bitmap>             : (Opt) Disable Z bars with 0.\n"
    print_msg "   --xavg <0,1,2,3,...>         : (Opt) Avg over selected X.\n"
    print_msg "   --yavg <0,1,2,3,...>         : (Opt) Avg over selected Y.\n"
    print_msg "   --xgeo                       : (Opt) Use with --xavg to enable geomean.\n"    
    print_msg "   --ygeo                       : (Opt) Use with --yavg to enable geomean.\n"
    print_msg "   --ignore,-i                  : (Opt) Ignore Filter ERROR.\n"
    print_msg "   --percent                    : (Opt) Change Y axis to show %% vals.\n"
    print_msg "   --noviewer                   : (Opt) Disable launching the VIEWER.\n"
    print_msg "   --forceviewer                : (Opt) Force enable the VIEWER.\n"
    print_msg "   --viewer <file viewer>       : (Opt) Prefer to use VIEWER.\n"
    print_msg "   --barw <bar width>           : (Opt) Set the bar width.\n"
    print_msg "   --linew <line width>         : (Opt) Set the line width.\n"
    print_msg "   --linetype <3,6,1,...>       : (Opt) Set the line type.\n"
    print_msg "   --pntsize <point size>       : (Opt) Set the line point size.\n"
    print_msg "   --pnttype <3,6,1,...>        : (Opt) Set the line point types.\n"
    print_msg "   --noappend                   : (Opt) Dont append moufoplot data to eps.\n"
    print_msg "   --outformat <eps|png|jpeg>   : (Opt) Select output file format.\n"
    print_msg "   --silent                     : (Opt) Silent output on screen.\n"
    print_msg "   --regen                      : (Opt) Regenerate graph from .eps file.\n"
    print_msg "   --version (or -v)            : Print version and exit.\n"
    print_msg "   --help                       : Print this help screen.\n"
    exit 1
}

# Append 1) The moufplot command
#        2) The .gp file contents
#        3) The data points
# to the eps file as comments
append_data_to_eps()
{
    if [ "${no_append}" == "YES" ]; then
	return
    fi
    print_msg "Appending moufoplot command to ${epsfile}...\n"
    echo "%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%" >> ${epsfile}
    echo "%% `version` , `gnuplot --version`" >> ${epsfile}
    echo "%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%" >> ${epsfile}
    # echo $@ | sed 's/^/%% /' >> ${epsfile}
    echo "moufoplot ${arguments_saved}" | sed 's/^/%% /' >> ${epsfile}

    print_msg "Appending numerical data (${data_file}) to ${epsfile}... Use --noappend to stop it.\n"
    echo "%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%" >> ${epsfile}
    echo "%% ${MOUFOPLOT_GP_DATA_STRING} ${data_file}" >> ${epsfile}
    echo "%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%" >> ${epsfile}
    cat ${data_file} | sed 's/^/%% /' >> ${epsfile}

    print_msg "Appending .gp file (${gpfname}) to ${epsfile}...\n"
    echo "%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%" >> ${epsfile}
    echo "%% ${MOUFOPLOT_GP_STRING} ${gpfname}" >> ${epsfile}
    echo "%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%" >> ${epsfile}
    cat ${gpfname} | sed 's/^/%% /' >> ${epsfile}


    print_msg "Appending data to ${epsfile}...\n"
    echo "%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%" >> ${epsfile}
    local moufodata_file
    if [ -d "${DIR}" ];then
	moufodata_file=/tmp/moufodata.data
    else
	moufodata_file=${DIR}
    fi
    echo "%% ${MOUFOPLOT_DATA_STRING} ${moufodata_file}" >> ${epsfile}
    echo "%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%" >> ${epsfile}
    if [ -d "${DIR}" ]; then
	local file
	for file in `ls -1 ${DIR}`; do

	    # Skip files that don't contain just one number. FIXME???
	    local count_lines=`head ${DIR}/${file} -n 5 | wc -l`
	    local count_words=`head ${DIR}/${file} -n 5 | wc -w`
	    if ([ ${count_lines} -ne 0 ]&&[ ${count_lines} -ne 1 ])||[ ${count_words} -ne 1 ]; then
		echo "skipping ${DIR}/${file}..."
		continue;
	    fi

	    # local value=`cat "${DIR}/${file}"`
	    local value=$(< "${DIR}/${file}") # Performance optimization
	    echo "%% ${file}:${value}" >> ${epsfile}
	done
    else
	cat ${DIR} | sed 's/^/%% /' >> ${epsfile}
    fi
    echo "%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%" >> ${epsfile}  
    echo "%% ${MOUFOPLOT_DATA_END_STRING} ${moufodata_file}" >> ${epsfile}
    echo "%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%" >> ${epsfile}  
}



findviewer()
{
    local viewers
    case "${suffix}" in
	"eps") viewers="evince,okular,kpdf,gv,inkscape,gimp";;
	"jpeg") viewers="gpicview,firefox,google-chrome,gimp";;
	"png") viewers="gpicview,firefox,google-chrome,gimp";;
	*) echo "ERROR in findviewer(). suffix:'${suffix}' unrecognized."; exit 1;;
    esac
    if [ "${eps_viewer}" != "" ];then
	viewers="${eps_viewer},${viewers}"
    fi
    local viewer
    RETVAL=""
    set_ifs ","
    for viewer in ${viewers}; do
	which ${viewer} 2> /dev/null 1> /dev/null
	if [ $? -eq 0 ];then
	    RETVAL=${viewer}
	    reset_ifs
	    return
	fi
    done
    print_msg "WARNING: No EPS viewer found in (${viewers}) to display ${epsfile}.\n"
    print_msg "Try using: --viewer \n" 
    reset_ifs
}

check_if_gnuplot_exists()
{
    gnuplot --help > /dev/null
    if [ $? -ne 0 ];then
	echo "ERROR: can't run gnuplot. Please install gnuplot"
	exit 1
    fi
}

# Check if the name of DIR looks like a directory.
check_if_directory()
{
    local dir=${1}
    echo ${dir} | grep "/$"
    if [ ${?} -eq 0 ]; then
	RETVAL=1
    else
	RETVAL=''
    fi
}


# Return the common filters in FIRST and SECOND
# For example if FIRST=isnsns_cl0 and SECOND=insns_cl1
# this function will return "insns"
get_matches()
{
    local first=${1}
    local second=${2}

    # echo "1:${first} 2:${second}"
    local all_matches=""
    local f
    set_ifs "_"
    for f in ${first}; do 
	local match=`echo _${second}_|grep -o _${f}_`
	if [ ${?} -eq 0 ]; then
	    all_matches="${all_matches}_${match}"
	fi
    done
    reset_ifs

    # echo "get_matches: ${all_matches}"
    RETVAL=`echo ${all_matches} | sed 's/^_//' | sed 's/_$//'`
}

# Strip INPUT from surrounding STRING
# Example: INPUT=_foo_bar_  STRING="_"
#          return "foo_bar"
strip()
{
    local input=${1}
    local string=${2}
    echo ${input} | sed "s/^${string}//" | sed "s/${string}$//"
}

# Return the underlying filter in X_FILTERS
# For example if -x insns_cl0,insns_cl1 there is a hidden
# underlying filter "insns"
get_hidden_filters()
{
    local x_filters=${1}
    local x_filter
    local x_tag
    local last_filter=`echo ${x_filters}|cut -f 1 -d ","`
    local match=${first_match}
    set_ifs ","
    for x_filter in ${x_filters}; do
	get_matches "${last_filter}" "${x_filter}"
	match=${RETVAL}
	# echo "MATCH:  ->${match}<-"
	last_filter=${x_filter}
    done
    reset_ifs
    # echo FINAL MATCH: ${match}
    echo `strip "${match}" "_"`
}


# Read the data existing in DATA_FILE in gnuplot data format and generate 
# a moufoplot compatible input data file. Place results in OUTPUT_FILE
regenerate_data()
{
    local data_file=${1}
    local output_file=${2}
    local i=-1
    local x_array
    local current_y
    local current_z


    local OTHERS_TAG
    local o_tag
    # Extra tags include: 1) the -filter, 2) the common filters in -x,-y,-z
    for o_tag in ${others}; do 
	OTHERS_TAG="${OTHERS_TAG}_${o_tag}"
    done

    local HIDDENT_TAG=""
    get_hidden_filters ${x_vals}
    HIDDEN_TAG="${HIDDEN_TAG}_${RETVAL}"
    HIDDEN_TAG=`strip "${HIDDEN_TAG}" "_"`
    get_hidden_filters ${y_vals}
    HIDDEN_TAG="${HIDDEN_TAG}_${RETVAL}"
    HIDDEN_TAG=`strip "${HIDDEN_TAG}" "_"`
    get_hidden_filters ${y_vals}
    HIDDEN_TAG="${HIDDEN_TAG}_${RETVAL}"
    HIDDEN_TAG=`strip "${HIDDEN_TAG}" "_"`
    printf "HIDDEN_TAG:${HIDDEN_TAG}\n"

    # Remove leading/trailing '_'
    OTHERS_TAG=`echo ${OTHERS_TAG} | sed 's/^_//' | sed 's/_$//'`
    printf "OTHERS_TAG:${OTHERS_TAG}\n"

    local EXTRA_TAGS="${HIDDEN_TAG}_${OTHERS_TAG}"
    EXTRA_TAGS=`strip "${EXTRA_TAGS}" "_"`
    printf "EXTRA_TAGS:${EXTRA_TAGS}\n"
    

    # If a directory, create it
    check_if_directory "${output_file}"
    local is_dir=${RETVAL}
    if [ ${is_dir} ]; then
	if [ ! -d ${output_file} ]; then
	    mkdir -p ${output_file}
	fi
    else 
	echo "" > ${output_file}
    fi

    while read line; do
	# echo ${line}

	# Skip empty lines
	words_in_line=`echo ${line}|wc -w`
	if [ ${words_in_line} -eq 0 ];then
	    continue
	fi 

	i=$((${i} + 1))
	# X axis
	if [ ${i} -eq 0 ];then
	    x_array=(`echo ${line} | cut -f 2- -d " "`)
	    continue
	else
	        # Z axis
	    local first=`echo ${line}|cut -f 1 -d " "`
	    if [ ${first} == "#" ];then
		current_z=`echo ${line}|cut -f 2 -d " "`
		continue
	    else
                # Y axis
		current_y=${first}
	    fi
	fi

	# Parse the numbers
	local wi=0
	for word in `echo ${line}|cut -f 2- -d " "`; do
	    if [ "${current_z}" != "#" ];then
		local TAG=${x_array[${wi}]}_${current_y}_${current_z}_${EXTRA_TAGS}
	    else 
		local TAG=${x_array[${wi}]}_${current_y}_${EXTRA_TAGS}
	    fi

	    if [ "${is_dir}" ];then
		echo "0${word}" > ${output_file}/${TAG}
	    else
		echo ${TAG}:0${word} >> ${output_file}
	    fi
	    wi=$((${wi} + 1))
	done
	
    done < ${data_file}
}

calculate_max_xyz()
{
    set_ifs ", "
    max_x=0
    for x in ${x_array}; do
	max_x=$((${max_x} + 1))
    done
    max_y=0
    for y in ${y_array}; do
	max_y=$((${max_y} + 1))
    done
    max_z=0
    for z in ${z_array}; do
	max_z=$((${max_z} + 1))
    done
    reset_ifs
}

# If we use --xavg or --yavg then we append "avg" to the vals.
append_avg_vals()
{
    if [ "${x_avg}" != "" ];then
	x_array="${x_array},avg"
	x_vals=${x_array}
    fi

    if [ "${y_avg}" != "" ];then
    	y_array="${y_array},avg"
	y_vals=${y_array}
    fi


    # avg

    calculate_max_xyz		# re-calculate (with avg)

    if [ "${y_avg}" != "" ];then
	local yi=0
	while [ ${yi} -lt ${max_x} ];do
	    if [ ${y_geomean_flag} ]; then
		ysum[${yi}]="1"
	    else
		ysum[${yi}]="0"
	    fi
	    yi=$((${yi} + 1))
	done
    fi

}

append_avg_tags()
{
    local avg_tag
    if [ "${x_avg}" != "" ];then
	if [ ${x_geomean_flag} ]; then
	    avg_tag="GMean"
	else
	    avg_tag="avg"
	fi
	x_tags=${x_tags},${avg_tag}
	xtags_array[${#xtags_array[@]}]=${avg_tag}
    fi

    if [ "${y_avg}" != "" ];then
	if [ ${y_geomean_flag} ]; then
	    avg_tag="GMean"
	else
	    avg_tag="avg"
	fi
	y_tags=${y_tags},${avg_tag}
	ytags_array[${#ytags_array[@]}]=${avg_tag}
    fi
}

moufoplot()
{
    check_if_gnuplot_exists
    IFS_CNT=0
    IFS_CHAR=','
    local CMD_ARGS=${@}
    parse_arguments ${CMD_ARGS}

    if [ $? -ne 0 ]; then exit 1; fi

    # If we are retrieving the arguments from the .eps file, we have to re-parse
    # the args.
    if [ ${regen} ];then 
	# See if .eps file contains the moufodata
	# If so, then retrieve it from there
	cat ${regen} | egrep "^%% ${MOUFOPLOT_DATA_STRING}" > /dev/null
	local moufodata_exists=${?}

	local tmp_moufoplot_options_file=/tmp/moufoplot.options.tmp
	restore_data "${regen}" "${MOUFOPLOT_STRING} " "${MOUFOPLOT_GP_DATA_STRING}" "${tmp_moufoplot_options_file}"
	local args=`cat ${tmp_moufoplot_options_file} | sed 's/moufoplot //'`
	print_msg "Regenerated ${MOUFOPLOT_STRING} command:\n ${args}\n"

	# Data points used to regenerate moufoplot data from them
	print_msg "Restoring data points from ${regen} --> ${data_file} ... \n"
	echo "" > ${data_file}
	restore_data "${regen}" "${MOUFOPLOT_GP_DATA_STRING}" "${MOUFOPLOT_GP_STRING}" "${data_file}"
	print_file ${data_file}

	# Get info like DATA_FILE, DIR etc.
	parse_arguments ${args}

	if [ ${moufodata_exists} -eq 0 ];then
	    local moufodata_file=/tmp/moufodata.data
	    echo "" > ${moufodata_file}
	    restore_data "${regen}" "${MOUFOPLOT_DATA_STRING} " "${MOUFOPLOT_DATA_END_STRING}" "${moufodata_file}"
	    print_msg "Regenerated moufodata:\n"
	    print_file ${moufodata_file}
	else
	    printf "******************************************************\n"
	    printf "No moufodata found on ${regen}.\n"
	    printf "This is probably because ${regen} has been generated\n"
	    printf "by some old version of ${MOUFOPLOT_STRING}.\n"
	    printf "I will try my best to retrieve the data.\n"
	    printf "Press enter to continue...\n"
	    printf "******************************************************\n"
	    read
	    printf "Regenerating data from ${data_file} into ${DIR}...\n"
	    regenerate_data ${data_file} ${DIR}
	    printf "\nRegenerated Data (in ${DIR}):\n"
	    if [ -d "${DIR}" ]; then
		ls -1 ${DIR}
	    elif [ -f "${DIR}" ]; then
		cat ${DIR}
	    fi
	fi 

	# Now that the DATA_FILE is populated, reparse the args
	IGNORE_REGEN=1
	# local CMD_ARGS_QUOTED=`echo ${CMD_ARGS}|sed 's/\"/\\\"/g'`
	# echo "QUOTED: ${CMD_ARGS_QUOTED}"
	# echo ${args}

	parse_arguments ${args} ${CMD_ARGS}
	if [ ${moufodata_exists} -eq 0 ];then 
	    DIR=${moufodata_file}
	fi
    fi

    sanity_checks

    append_avg_vals
    append_avg_tags


    set_defaults
    # if [ $? -ne 0 ]; then exit 1; fi


    if [ "${plot_type}" == "heatmap" ];then
	create_data_file_hmap "${others}"
	gp_hmap_options 
    elif [ "${plot_type}" == "bargraph" ];then
	create_data_file "" "${others}"
	gp_bar_options
    elif [ "${plot_type}" == "linegraph" ];then
	create_data_file "" "${others}"
	gp_line_options
    elif [ "${plot_type}" == "stacked" ];then
	create_data_file "rowstacked" "${others}"
	gp_bar_options "rowstacked"
    fi

    local gnuplot_cmd="gnuplot ${gpfname}"
    eval ${gnuplot_cmd}
    if [ $? -ne 0 ];then
	echo "ERROR: in ${gnuplot_cmd}"
	exit 1
    fi

    # Append Data to EPS file
    append_data_to_eps "$@"

    # View EPS file
    findviewer
    local viewer=${RETVAL}
    if [ "${viewer}" != "" ]&&[ "${no_viewer}" != "YES" ];then
	print_msg "View ${epsfile} using ${viewer}\n"
	local viewcmd="${viewer} ${epsfile} "
	print_msg "${viewcmd}\n"
	eval ${viewcmd}
    fi
}

# Fix the argument form, :
# From: -arg "OPTION1 OPTION2"  OR -arg 'OPTION1 OPTION2'
# To  : -arg \"OPTION1 OPTION2\" 
while [ 0 ]; do
    if [ "${1}" ]; then
	arg=${1}
	echo ${arg} |grep "^-" > /dev/null
	# If -option OR --option
	if [ ${?} -eq 0 ]; then
	    arg_esc=${arg}
	else
	    arg_esc="\"${arg}\""
	fi
	args_escaped="${args_escaped} ${arg_esc}"
	shift
	# echo ${args_escaped}
    else
	break
    fi
done
init_ifs
moufoplot "${args_escaped}"

